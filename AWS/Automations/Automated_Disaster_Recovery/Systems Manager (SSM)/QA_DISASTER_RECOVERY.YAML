description: |-
  # **QA FAILOVER**  

  ---
  ## INSTRUCTIONS FOR RUNNING AUTOMATION


  1. *Click on "Execute Automation" in the top right corner.*
  2. *Choose Multi-Account and Region.*
  3. *For targets accounts, enter (AWS_ACCOUNT_NUMBER).*
  4. *Set the region as us-east-1 OR us-west-2.*
  - **NOTE**: Do not choose more than one region, otherwise the automation will run twice.
  5. *Scroll down to the bottom and hit "Execute."*
  6. *Automation step Outputs can be seen by clicking "Automation" under "Change Management" on the left-hand toolbar, clicking on the execution ID of the automation running, clicking on the StepID, then the ExecutionID. Clicking on individual Step IDs after this will display the outputs of each step.*



  Error Codes and Troubleshooting documention // [WIKI]([DOCUMENTATION LINK HERE])

  Further documentation regarding the automation // [WIKI]([DOCUMENTATION LINK HERE])
schemaVersion: '0.3'
assumeRole: '{{ AutomationAssumeRole }}'
parameters:
  AutomationAssumeRole:
    type: String
    description: The IAM role that runs the automation (DO NOT CHANGE.)
    allowedPattern: '^$|^arn:aws:iam::[0-9]*:role/[/\w+=,.@-]+$'
    default: 'arn:aws:iam::[AWS_ACCOUNT_NUMBER]:role/AWS-SystemsManager-AutomationAdministrationRole'
  SlackChannel:
    type: String
    allowedValues:
      - MICROSERVICE-release
      - MICROSERVICE-devops
      - emergency-room
      - alarm
    description: Specify which slack channel you would like to send the start and end notifications for this failover automation.
    default: MICROSERVICE-devops
mainSteps:



# ----------------------------------------------------------------------------------------------------------------------------------------------------



  - name: retrieveRegions
    action: 'aws:executeScript'
    inputs:
      Runtime: python3.6
      Handler: get_active_stack
      Script: |

        import boto3
        import json
        from datetime import datetime
        from botocore.exceptions import ClientError

        def get_active_stack(event,context):
          
          #variables
          region_east = event['REGION_EAST']
          region_west = event['REGION_WEST']
          dt_raw = datetime.now()
          current_datetime = dt_raw.strftime("%Y-%m-%dT%H:%M:00Z")
          print_datetime = dt_raw.strftime("%m/%d/%Y %H:%M:%S")
          wikiLink = 'REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION LINK HERE]'
          failoverLog = [f"\t\t-- POST MICROSERVICE FAILOVER LOG --\n\nTHE CURRENT DATE AND TIME IS: {print_datetime}.\n"]
          failoverLog.append("STEP: retrieveRegions\n\n")
          
          #posts slack notification
          slack = event['SlackChannel']
          snsclient = boto3.client('sns')
          snsArn = 'arn:aws:sns:us-east-1:AWSACCOUNT#:MICROSERVICE_FAILOVER_NOTIF'
          message = f"FAILOVER START TIME: {print_datetime}\nCHANNEL: {slack}"
          
          try:
            if ((slack == 'MICROSERVICE-release') or (slack == 'MICROSERVICE-devops') or (slack == 'emergency-room')):
              response = snsclient.publish(
                TopicArn = snsArn,
                Message = message,
                MessageAttributes={
                  'Channel': {
                    'DataType': 'String',
                    'StringValue': f"{slack}"
                  }
                },
                Subject = "MICROSERVICE QA FAILOVER HAS BEEN TRIGGERED."
              )
            elif (slack == 'alarm'):
              response = snsclient.publish(
                TopicArn = snsArn,
                Message = message,
                MessageAttributes={
                  'Channel': {
                    'DataType': 'String',
                    'StringValue': f"{slack}"
                  }
                },
                Subject = "MICROSERVICE QA FAILOVER TRIGGERED VIA ALARM. PLEASE NOTIFY @oncall AND ALL RELEVANT RESOURCES."
              )
          except:
            print("UNABLE TO POST TO SLACK.")
          
          failoverLog.append("YOU HAVE CHOSEN TO RUN THE FAILOVER IN MICROSERVICE-QA...")

          #get the secret from us-east-1
          session = boto3.session.Session()
          try:
            secret_name = "arn:aws:secretsmanager:us-east-1:AWSACCOUNT#:secret:MICROSERVICE-QA-STACKS"
            client = session.client(service_name='secretsmanager',region_name="us-east-1")
            get_secret_value_response = client.get_secret_value(SecretId=secret_name)
            
          #if failed to get secrets from us-east-1, try replica in us-west-2
          except:
            failoverLog.append("\nFAILED TO RETRIEVE SECRETS FROM US-EAST-1 !! RETRIEVING SECRETS FROM US-WEST-2...")
            secret_name = "arn:aws:secretsmanager:us-west-2:AWSACCOUNT#:secret:MICROSERVICE-QA-STACKS"
            client = session.client(service_name='secretsmanager',region_name="us-west-2")
            get_secret_value_response = client.get_secret_value(SecretId=secret_name)
            
          #parsing secrets and saving them as vars
          MICROSERVICE_secrets = json.loads(get_secret_value_response['SecretString'])
          active_stack = MICROSERVICE_secrets['PRIMARY_MICROSERVICE_QA_STACK'] #active region in secrets manager
          credsEast = MICROSERVICE_secrets['QA_MASTER_CONNECTION_EAST'] #docdb master credentials for the east region
          credsWest = MICROSERVICE_secrets['QA_MASTER_CONNECTION_WEST'] #docdb master credentials for the west region
          LM_API_ID = MICROSERVICE_secrets['LM_API_ID'] #logicmonitor API key
          LM_API_KEY = MICROSERVICE_secrets['LM_API_KEY'] #logicmonitor secret key
          
          if (active_stack == 'EAST'):
              active_region=region_east
              standby_region=region_west
          elif (active_stack == 'WEST'):
              active_region=region_west
              standby_region=region_east
          
          failoverLog.append(f"\n-- -- -- -- -- -- -- -- -- -- --\nTHE CURRENT ACTIVE REGION IN MICROSERVICE-QA IS: {active_region}.\nTHE CURRENT STANDBY REGION IN MICROSERVICE-QA IS: {standby_region}.")
          
          return {'ACTIVE_REGION': active_region, 'STANDBY_REGION': standby_region, 'CREDS_EAST': credsEast,'CREDS_WEST': credsWest, 'LM_API_ID': LM_API_ID , 'LM_API_KEY': LM_API_KEY,'DATE_TIME': current_datetime, 'WIKI_LINK': wikiLink, 'FAILOVER_LOG': failoverLog}

      InputPayload:
        REGION_EAST: us-east-1
        REGION_WEST: us-west-2
        SlackChannel: '{{SlackChannel}}'
    outputs:
      - Name: ACTIVE_REGION
        Selector: $.Payload.ACTIVE_REGION
        Type: String
      - Name: STANDBY_REGION
        Selector: $.Payload.STANDBY_REGION
        Type: String
      - Name: CREDS_EAST
        Selector: $.Payload.CREDS_EAST
        Type: String
      - Name: CREDS_WEST
        Selector: $.Payload.CREDS_WEST
        Type: String
      - Name: LM_API_ID
        Selector: $.Payload.LM_API_ID
        Type: String
      - Name: LM_API_KEY
        Selector: $.Payload.LM_API_KEY
        Type: String
      - Name: DATE_TIME
        Selector: $.Payload.DATE_TIME
        Type: String
      - Name: WIKI_LINK
        Type: String
        Selector: $.Payload.WIKI_LINK
      - Name: FAILOVER_LOG
        Selector: $.Payload.FAILOVER_LOG
        Type: StringList
    description: Retrieves regions and credentials



# ----------------------------------------------------------------------------------------------------------------------------------------------------



  - name: upsizeStandby
    action: 'aws:executeScript'
    inputs:
      Runtime: python3.6
      Handler: modify_instance_type
      Script: |

        import boto3
        import botocore
        import re

        def modify_instance_type(event,context):
          
          #variables
          failoverLog = event['failoverLog']
          failoverLog.append("STEP: upsizeStandby\n\n")
          wiki = event['wikiLink']
          standby_region = event['region']
          instanceType = 'db.r6g.large' #instance type to upsize to
          successCounter = 0
          responseOutputs = []
          if (standby_region == 'us-west-2'):
            nodeList = ["QA-MICROSERVICE-db-node-0"] #docDB nodes in us-west-2
          elif (standby_region == 'us-east-1'):
            nodeList = ["QA-MICROSERVICE-db-node-0","QA-MICROSERVICE-db-node-1","QA-MICROSERVICE-db-node-2"] #docDB nodes in us-east-1
          

          #upsizes standby region nodes
          client = boto3.client('docdb',region_name=standby_region)
          
          for x in range(len(nodeList)):
            response = client.modify_db_instance(
              DBInstanceIdentifier=nodeList[x],
              DBInstanceClass=instanceType,
              ApplyImmediately=True,
              )
            responseOutputs.append(response)
            
          #parsing response output from instances
          for i in range(len(responseOutputs)):
            try:
              parseResponseOutput = responseOutputs[i]["DBInstance"]["PendingModifiedValues"]["DBInstanceClass"]
              if (parseResponseOutput == instanceType):
                successCounter += 1
            except AttributeError:
              if re.search(r"\b'PendingModifiedValues': {'DBInstanceClass': 'db.r6g.large'}\b", str(responseOutputs[i])):
                successCounter += 1
            except:
              failoverLog.append(f"THERE WAS AN ISSUE VALIDATING SUCCESS FOR {nodeList[i]}.\n")
          
          #--- validate step success ---
          if (successCounter == len(nodeList)):
            log = f"STEP STATUS: SUCCESS!\n{successCounter} OF {len(nodeList)} NODES HAVE SUCCESSFULLY BEEN SENT THE REQUEST TO UPSIZE."
          elif (successCounter != len(nodeList)):
            log = f"STEP STATUS: FAILED!\nERROR CODE: 2A\n{successCounter} OF {len(nodeList)} NODES WERE SENT THE REQUEST TO UPSIZE.\nNOTE: THE INSTANCES COULD ALREADY BE SCALED UP. PLEASE CHECK THE DOCDB NODES IN {standby_region} TO CONFIRM THEY ARE SCALED UP.\n{wiki}"
          else:
            log = f"STEP STATUS: UNKNOWN!\nERROR CODE: 2B\nTHERE WAS AN ISSUE RETRIEVING OUTPUTS FROM THE MODIFY DOCDB REQUESTS. THIS DOES NOT MEAN THE REQUESTS WERE NOT SENT, PLEASE CHECK THE DOCDB NODES IN {standby_region} TO CONFIRM THEY ARE IN A MODIFYING STATE.\n{wiki}"

          failoverLog.append("\n" + log)
          return {'FAILOVER_LOG': failoverLog}

      InputPayload:
        region: '{{retrieveRegions.STANDBY_REGION}}'
        wikiLink: '{{retrieveRegions.WIKI_LINK}}'
        failoverLog: '{{retrieveRegions.FAILOVER_LOG}}'
    description: Scales up the standby region
    outputs:
      - Name: FAILOVER_LOG
        Selector: $.Payload.FAILOVER_LOG
        Type: StringList



# ----------------------------------------------------------------------------------------------------------------------------------------------------



  - name: waitUntilStandbyIsUpsized
    action: 'aws:executeScript'
    inputs:
      Runtime: python3.6
      Handler: wait_instance_type
      Script: |-

        import boto3
        import botocore
        import time

        def wait_instance_type(event,context):
          
          time.sleep(60)
          
          #variables
          failoverLog = event['failoverLog']
          failoverLog.append("STEP: waitUntilStandbyIsUpsized\n")
          wiki = event['wikiLink']
          standby_region = event['region']
          successCounter = 0
          if (standby_region == 'us-west-2'):
            nodeList = ["QA-MICROSERVICE-db-node-0"] #docDB nodes in us-west-2
          elif (standby_region == 'us-east-1'):
            nodeList = ["QA-MICROSERVICE-db-node-0","QA-MICROSERVICE-db-node-1","QA-MICROSERVICE-db-node-2"] #docDB nodes in us-east-1
          

          #waits until the docdb nodes are scaled up
          client = boto3.client('docdb',region_name=standby_region)
          waiter = client.get_waiter('db_instance_available')
          
          for x in range(len(nodeList)):
            waiter.wait(
              DBInstanceIdentifier=nodeList[x],
              WaiterConfig={
                  'Delay': 20
              }
            )
            successCounter += 1
            failoverLog.append(f"WAIT COMPLETE FOR {nodeList[x]} IN {standby_region}.\n")
          
            
          #--- validate step success ---
          if (successCounter == len(nodeList)):
            log = f"STEP STATUS: SUCCESS!\n{successCounter} OF {len(nodeList)} NODES HAVE SUCCESSFULLY BEEN SCALED UP.\n"
          elif (successCounter != len(instanceList)):
            log = f"STEP STATUS: FAILED!\nERROR CODE: 3A\n{successCounter} OF {len(nodeList)} NODES HAVE BEEN SCALED UP.\n{wiki}"
          else:
            log = f"STEP STATUS: UNKNOWN!\nERROR CODE: 3B\nTHERE WAS AN ISSUE VALIDATING STEP SUCCESS. THIS DOES NOT MEAN THE DOCDB NODES ARE NOT SCALED UP. PLEASE CHECK THE DOCDB NODES IN {standby_region} TO CONFIRM THEY ARE SCALED UP.\n{wiki}"

          failoverLog.append("\n" + log)      
          return {'FAILOVER_LOG': failoverLog}

      InputPayload:
        region: '{{retrieveRegions.STANDBY_REGION}}'
        wikiLink: '{{retrieveRegions.WIKI_LINK}}'
        failoverLog: '{{upsizeStandby.FAILOVER_LOG}}'
    description: waits until the standby docdb nodes have reached an available state before moving forward
    outputs:
      - Name: FAILOVER_LOG
        Selector: $.Payload.FAILOVER_LOG
        Type: StringList



# ----------------------------------------------------------------------------------------------------------------------------------------------------



  - name: runMongoQueriesActiveStack
    action: 'aws:executeScript'
    inputs:
      Runtime: python3.6
      Handler: runMongoQueriesActiveStack
      Script: |-

        import boto3
        import json
        import botocore
        import re

        def runMongoQueriesActiveStack(event,context):

          #variables
          failoverLog = event['failoverLog']
          failoverLog.append("STEP: runMongoQueriesActiveStack\n")
          wiki = event['wikiLink']
          active_region=event['active_region']
          if (active_region == 'us-east-1'):
            creds = event['credsEast'] #docdb master credentials for the east region
          elif (active_region == 'us-west-2'):
            creds = event['credsWest'] #docdb master credentials for the west region
          lambdaPayload={"region":active_region,"creds":creds,"readOnly":"false"} #creates payload to be sent to lambda
          
          failoverLog.append(f"THE CURRENT ACTIVE REGION IS {active_region}.\nDISABLING MICROSERVICE API CALLS IN THE DATABASE FOR THIS REGION...\n\n")

          #trigger lambda to run queries in DB
          client = boto3.client(service_name='lambda',region_name=active_region)
          response = client.invoke(
            FunctionName=f"arn:aws:lambda:{active_region}:AWSACCOUNT#:function:runMongoQueries",
            InvocationType='RequestResponse',
            LogType='Tail',
            Payload=json.dumps(lambdaPayload)
            )
          
          #prints lambda output
          lineBreak = "-- -- -- -- -- -- -- -- -- -- --\n"
          lambdaOutput = response['Payload']
          LO = lambdaOutput.read()
          LO_remove_backslash = str(LO).replace("\\","")
          LO_parsed = str(LO_remove_backslash).split(",")
          failoverLog.append(lineBreak + "THE NEW VALUES FROM THE DATABASE ARE AS FOLLOWS:\n\n")
          for x in LO_parsed:
            failoverLog.append(x + "\n")
          
          #microservice disabled parsing
          microService1Check = re.search(r"{\\'microServiceDisabled\\': (.*)}}]\"', ' \"Reports\"", str(LO_parsed))

          #reports parsing
          microService2Check = re.search(r"'sendToS3\\': (.*)}', \" 'report1':", str(LO_parsed))
          microService3Check = re.search(r"{'sendToS3': (.*)}\", \" 'report2':", str(LO_parsed))
          microService4Check = re.search(r"'report2': {'sendToS3': (.*)}\", ' \\'report3\\'", str(LO_parsed))
          microService5Check = re.search(r"'report3\\': {\\'sendToS3\\': (.*)}}}}]\"'", str(LO_parsed))

          #partners config parsing
          partner1Check = re.search(r"{\\'partner1\\': {\\'apiInfo\\': {\\'fakeApi\\': (.*)}}', \"", str(LO_parsed))
          partner3Check = re.search(r"\" 'partner3': {'apiInfo': {'fakeApi': (.*)}}\", ' \\'partner2\\':", str(LO_parsed))
          partner2Check = re.search(r"'partner2\\': {\\'apiInfo\\': {\\'fakeApi\\': (.*)}}}}}]", str(LO_parsed))
          
          #--- validate step success ---
          try:
            if ((microService1Check.group(1) == 'True') and (microService2Check.group(1) == 'False') and (microService3Check.group(1) == 'False') and (microService4Check.group(1) == 'False') and (microService5Check.group(1) == 'False') and (partner1Check.group(1) == 'True') and (partner3Check.group(1) == 'True') and (partner2Check.group(1) == 'True')):
              log = "STEP STATUS: SUCCESS!"
            elif ((microService1Check.group(1) == 'False') and (microService2Check.group(1) == 'True') and (microService3Check.group(1) == 'True') and (microService4Check.group(1) == 'True') and (microService5Check.group(1) == 'True') and (partner1Check.group(1) == 'False') and (partner3Check.group(1) == 'False') and (partner2Check.group(1) == 'False')):
              log = f"STEP STATUS: FAILED!\nERROR CODE: 4A\nIT LOOKS LIKE THE VALUES FAILED TO UPDATE IN THE DATABASE.\n{wiki}"
            else:
              log = f"STEP STATUS: FAILED!\nERROR CODE: 4B\nIT LOOKS LIKE SOME OF THE VALUES UPDATED AND SOME DIDN'T.\n{wiki}"
          except:
            log = f"STEP STATUS: UNKNOWN!\nERROR CODE: 4C\nTHERE WAS EITHER AN ISSUE TRIGGERING THE LAMBDA OR VALIDATING STEP SUCCESS. PLEASE REVIEW THE ABOVE OUTPUT FROM THE DATABASE IF IT EXISTS AND CONFIRM THE TRUE/FALSE VALUES FOLLOW THIS PATTERN:\nTRUE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE\n{wiki}"
          
          failoverLog.append("\n" + log)
          return {'FAILOVER_LOG': failoverLog}
      
      InputPayload:
        active_region: '{{retrieveRegions.ACTIVE_REGION}}'
        credsEast: '{{retrieveRegions.CREDS_EAST}}'
        credsWest: '{{retrieveRegions.CREDS_WEST}}'
        wikiLink: '{{retrieveRegions.WIKI_LINK}}'
        failoverLog: '{{waitUntilStandbyIsUpsized.FAILOVER_LOG}}'
    description: 'Disables microservice API calls in the active region db'
    outputs:
      - Name: FAILOVER_LOG
        Selector: $.Payload.FAILOVER_LOG
        Type: StringList



# ----------------------------------------------------------------------------------------------------------------------------------------------------



  - name: runMongoQueriesStandbyStack
    action: 'aws:executeScript'
    inputs:
      Runtime: python3.6
      Handler: runMongoQueriesStandbyStack
      Script: |-

        import boto3
        import json
        import botocore
        import re

        def runMongoQueriesStandbyStack(event,context):

          #variables
          failoverLog = event['failoverLog']
          failoverLog.append("STEP: runMongoQueriesStandbyStack\n")
          wiki = event['wikiLink']
          active_region=event['active_region']
          standby_region=event['standby_region']
          if (standby_region == 'us-east-1'):
            creds = event['credsEast'] #docdb master credentials for the east region
          elif (standby_region == 'us-west-2'):
            creds = event['credsWest'] #docdb master credentials for the west region
          lambdaPayload={"region":active_region,"creds":creds,"readOnly":"false"} #creates payload to be sent to lambda
          
          
          failoverLog.append(f"THE CURRENT STANDBY REGION IS {standby_region}.\nENABLING MICROSERVICE API CALLS IN THE DATABASE FOR THIS REGION...\n\n")

          #trigger lambda to run queries in DB
          client = boto3.client(service_name='lambda',region_name=standby_region)
          response = client.invoke(
            FunctionName=f"arn:aws:lambda:{standby_region}:AWSACCOUNT#:function:runMongoQueries",
            InvocationType='RequestResponse',
            LogType='Tail',
            Payload=json.dumps(lambdaPayload)
            )
          
          #prints lambda output
          lineBreak = "-- -- -- -- -- -- -- -- -- -- --\n"
          lambdaOutput = response['Payload']
          LO = lambdaOutput.read()
          LO_remove_backslash = str(LO).replace("\\","")
          LO_parsed = str(LO_remove_backslash).split(",")
          failoverLog.append(lineBreak + "THE NEW VALUES FROM THE DATABASE ARE AS FOLLOWS:\n\n")
          for x in LO_parsed:
            failoverLog.append(x + "\n")
          
          #micro service disabled parsing
          microService1Check = re.search(r"{\\'microServiceDisabled\\': (.*)}}]\"', ' \"Reports\"", str(LO_parsed))

          #reports parsing
          microService2Check = re.search(r"'sendToS3\\': (.*)}', \" 'report1':", str(LO_parsed))
          microService3Check = re.search(r"{'sendToS3': (.*)}\", \" 'report2':", str(LO_parsed))
          microService4Check = re.search(r"'report2': {'sendToS3': (.*)}\", ' \\'report3\\'", str(LO_parsed))
          microService5Check = re.search(r"'report3\\': {\\'sendToS3\\': (.*)}}}}]\"'", str(LO_parsed))

          #partners config parsing
          partner1Check = re.search(r"{\\'partner1\\': {\\'apiInfo\\': {\\'fakeApi\\': (.*)}}', \"", str(LO_parsed))
          partner3Check = re.search(r"\" 'partner3': {'apiInfo': {'fakeApi': (.*)}}\", ' \\'partner2\\':", str(LO_parsed))
          partner2Check = re.search(r"'partner2\\': {\\'apiInfo\\': {\\'fakeApi\\': (.*)}}}}}]", str(LO_parsed))
          
          #--- validate step success ---
          try:
            if ((microService1Check.group(1) == 'False') and (microService2Check.group(1) == 'True') and (microService3Check.group(1) == 'True') and (microService4Check.group(1) == 'True') and (microService5Check.group(1) == 'True') and (partner1Check.group(1) == 'False') and (partner3Check.group(1) == 'False') and (partner2Check.group(1) == 'False')):
              log = "STEP STATUS: SUCCESS!"
            elif ((microService1Check.group(1) == 'True') and (microService2Check.group(1) == 'False') and (microService3Check.group(1) == 'False') and (microService4Check.group(1) == 'False') and (microService5Check.group(1) == 'False') and (partner1Check.group(1) == 'True') and (partner3Check.group(1) == 'True') and (partner2Check.group(1) == 'True')):
              log = f"STEP STATUS: FAILED!\nERROR CODE: 5A\nIT LOOKS LIKE THE VALUES FAILED TO UPDATE IN THE DATABASE.\n{wiki}"
            else:
              log = f"STEP STATUS: FAILED!\nERROR CODE: 5B\nIT LOOKS LIKE SOME OF THE VALUES UPDATED AND SOME DIDN'T. THIS MAY BE DUE TO THE LAMBDA READING FROM THE DATABASE BEFORE IT ACTUALLY UPDATED.\n{wiki}"
          except:
            log = f"STEP STATUS: UNKNOWN!\nERROR CODE: 5C\nTHERE WAS EITHER AN ISSUE TRIGGERING THE LAMBDA OR VALIDATING STEP SUCCESS. PLEASE REVIEW THE ABOVE OUTPUT FROM THE DATABASE IF IT EXISTS AND CONFIRM THE TRUE/FALSE VALUES FOLLOW THIS PATTERN:\nFALSE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE.\n{wiki}"
          
          failoverLog.append("\n" + log)
          return {'FAILOVER_LOG': failoverLog}
            
      InputPayload:
        active_region: '{{retrieveRegions.ACTIVE_REGION}}'
        standby_region: '{{retrieveRegions.STANDBY_REGION}}'
        credsEast: '{{retrieveRegions.CREDS_EAST}}'
        credsWest: '{{retrieveRegions.CREDS_WEST}}'
        wikiLink: '{{retrieveRegions.WIKI_LINK}}'
        failoverLog: '{{runMongoQueriesActiveStack.FAILOVER_LOG}}'
    description: |
      Enables microservice API calls in the standby region db
    outputs:
      - Name: FAILOVER_LOG
        Selector: $.Payload.FAILOVER_LOG
        Type: StringList




# ----------------------------------------------------------------------------------------------------------------------------------------------------



  - name: restartMenuCollectorServices
    action: 'aws:executeScript'
    inputs:
      Runtime: python3.6
      Handler: restartMenuCollectorServices
      Script: |

        import boto3
        import botocore
        import time
        import re

        def restartSpecificServices(event,context):
          
          #variables
          failoverLog = event['failoverLog']
          failoverLog.append("STEP: restartSpecificServices\n")
          wiki = event['wikiLink']
          date_time = event['date_time']
          active_region=event['active_region']
          if (active_region == 'us-east-1'):
            associationID = "associationID" #restartSpecificServices association in East
            instanceList = ["InstanceId","InstanceId"] #MICROSERVICE_QA_INSTANCES_EAST
          elif (active_region == 'us-west-2'):
            associationID = "associationID" #restartSpecificServices association in West
            instanceList = ["InstanceId","InstanceId"] #MICROSERVICE_QA_INSTANCES_WEST
          successCounter = 0
          
          client = boto3.client(service_name='ssm',region_name=active_region)
          
          response = client.start_associations_once(
            AssociationIds=[associationID]
            )

          time.sleep(20)
          
          #getting the command ID
          getCommandId = client.list_command_invocations(
            InstanceId=instanceList[0],
            Filters=[
                {
                  'key': 'InvokedAfter',
                  'value': date_time
                }
              ],
            )
          
          #parsing the command ID
          
          try:
            command_ID = getCommandId["CommandInvocations"][0]["CommandId"]

            #getting association output from instances
            associationOutputs = []
            for i in range(len(instanceList)):
              associationOutput = client.get_command_invocation(
                CommandId=command_ID,
                InstanceId=instanceList[i],
              )
              associationOutputs.append(associationOutput)
          
            #parsing association output from instances
            for x in range(len(associationOutputs)):
              parseAssociationOutput = re.search(r"update-env to update environment variables(.*)', 'StandardOutputUrl':", str(associationOutputs[x]))
              if re.search(r"\bApplying action restartProcessId\b", str(associationOutputs[x])):
                successCounter += 1

            #--- validate step success ---
            if (successCounter == len(instanceList)):
              log = f"STEP STATUS: SUCCESS!\n{successCounter} OF {len(instanceList)} INSTANCES SUCCESSFULLY RAN THE restartSpecificServices ({associationID}) ASSOCIATION."
            elif (successCounter != len(instanceList)):
              log = f"STEP STATUS: FAILED!\nERROR CODE: 6A\nONLY {successCounter} OF {len(instanceList)} INSTANCES WERE ABLE TO RUN THE restartSpecificServices ({associationID}) ASSOCIATION.\n{wiki}"
          except AttributeError:
            failoverLog.append('THERE WAS AN ISSUE RETRIEVING OUTPUTS FROM THE ASSOCIATION. CHECKING ASSOCIATION STATUS...')
            #if unable to grab or parse commandID, grabs association details
            output = client.describe_association(
              AssociationId=associationID,
              AssociationVersion='$LATEST'
              )
          
            validateSuccess = output["AssociationDescription"]["Overview"]["Status"]
            
            if (validateSuccess == 'Success'):
              log = f"STEP STATUS: SUCCESS!\nTHE restartSpecificServices ({associationID}) ASSOCIATION WAS RUN SUCCESSFULLY!"
            elif (validateSuccess == 'Pending'):
              log = f"STEP STATUS: IN PROGRESS!THE ASSOCIATION IS STILL IN PROGRESS. MAKE SURE TO CHECK THE restartSpecificServices ({associationID}) ASSOCIATION IN MICROSERVICE-QA TO CONFIRM IT COMPLETES SUCCESSFULLY."
          except:
            log = f"STEP STATUS: UNKNOWN!\nERROR CODE: 6B\nASSOCIATION ID: {associationID}\nTHERE WAS AN ISSUE RETRIEVING OUTPUTS FROM THE ASSOCIATION. THIS DOES NOT MEAN THAT THE COMMANDS WERE NOT RUN.\n{wiki}"
          
          failoverLog.append("\n" + log)
          return {'FAILOVER_LOG': failoverLog}
          
              InputPayload:
                active_region: '{{retrieveRegions.ACTIVE_REGION}}'
                date_time: '{{retrieveRegions.DATE_TIME}}'
                wikiLink: '{{retrieveRegions.WIKI_LINK}}'
                failoverLog: '{{runMongoQueriesStandbyStack.FAILOVER_LOG}}'
    description: Restart specific services on the current primary stack to honor new database values
    outputs:
      - Name: FAILOVER_LOG
        Selector: $.Payload.FAILOVER_LOG
        Type: StringList



# ----------------------------------------------------------------------------------------------------------------------------------------------------



  - name: restartAllServices
    action: 'aws:executeScript'
    inputs:
      Runtime: python3.6
      Handler: restartAllServices
      Script: |

        import boto3
        import botocore
        import time
        import re

        def restartAllServices(event,context):

          #variables
          failoverLog = event['failoverLog']
          failoverLog.append("STEP: restartAllServices\n")
          wiki = event['wikiLink']
          date_time = event['date_time']
          standby_region=event['standby_region']
          if (standby_region == 'us-east-1'):
            associationID = "associationID" #restartAllServices association in East
            instanceList = ["InstanceId","InstanceId","InstanceId","InstanceId","InstanceId","InstanceId","InstanceId"] #MICROSERVICE_QA_APPLICATION_INSTANCES_EAST
            clusterN = 'MICROSERVICE-qa'
          elif (standby_region == 'us-west-2'):
            associationID = "associationID" #restartAllServices association in West
            instanceList = ["InstanceId","InstanceId","InstanceId","InstanceId","InstanceId","InstanceId","InstanceId"] #MICROSERVICE_QA_APPLICATION_INSTANCES_WEST
            clusterN = 'MICROSERVICE-qa-west'
          successCounter = 0
          serviceN = 'QA-MICROSERVICE-processor'

          
          client = boto3.client(service_name='ssm',region_name=standby_region)
          ecsclient = boto3.client(service_name='ecs',region_name=standby_region)
          
          #trigger associations
          response = client.start_associations_once(
            AssociationIds=[associationID]
            )
          
          #trigger task refresh
          listTasks = ecsclient.list_tasks(
            cluster=clusterN,
            serviceName=serviceN,
            )
          
          currentTasks = listTasks["taskArns"]
          cycleTasks = ecsclient.update_service(
            cluster=clusterN,
            service=serviceN,
            forceNewDeployment=True
            )

          #waits until the service reaches a steady state
          waiter = ecsclient.get_waiter('services_stable')
          try:
            waiter.wait(
              cluster=clusterN,
              services=[serviceN]
            )
          except:
            OPstatus = 'bad'
          else:
            OPstatus = 'good'
          
          #getting the command ID
          getCommandId = client.list_command_invocations(
            InstanceId=instanceList[0],
            Filters=[
                {
                  'key': 'InvokedAfter',
                  'value': date_time
                }
              ],
            )

          try:
            command_ID = getCommandId["CommandInvocations"][0]["CommandId"]
            
            #getting association output from instances
            associationOutputs = []
            for i in range(len(instanceList)):
              associationOutput = client.get_command_invocation(
                CommandId=command_ID,
                InstanceId=instanceList[i],
              )
              associationOutputs.append(associationOutput)
          
            #parsing association output from instances
            for x in range(len(associationOutputs)):
              parseAssociationOutput = re.search(r"update-env to update environment variables(.*)', 'StandardOutputUrl':", str(associationOutputs[x]))
              if re.search(r"\bApplying action restartProcessId\b", str(associationOutputs[x])):
                successCounter += 1
            
            #--- validate step success ---
            if ((successCounter == len(instanceList)) and (OPstatus == 'good')):
              log = f"STEP STATUS: SUCCESS!\n{successCounter} OF {len(instanceList)} INSTANCES SUCCESSFULLY RAN THE restartAllServices ({associationID}) ASSOCIATION AND PROCESSOR ECS TASKS HAVE BEEN CYCLED."
            elif ((successCounter != len(instanceList)) and (OPstatus == 'good')):
              log = f"STEP STATUS: FAILED!\nERROR CODE: 7A\nONLY {successCounter} OF {len(instanceList)} INSTANCES WERE ABLE TO RUN THE restartAllServices ({associationID}) ASSOCIATION. PLEASE CHECK EACH APPLICATION INSTANCE MANUALLY.\n{wiki}"
            elif ((successCounter == len(instanceList)) and (OPstatus == 'bad')):
              log = f"STEP STATUS: FAILED!\nERROR CODE: 7C\nPROCESSOR FAILED TO CYCLE TASKS.\n{wiki}"
          except AttributeError:
            failoverLog.append('THERE WAS AN ISSUE RETRIEVING OUTPUTS FROM THE ASSOCIATION. CHECKING ASSOCIATION STATUS...')
            #if unable to grab or parse commandID, grabs association details
            output = client.describe_association(
              AssociationId=associationID,
              AssociationVersion='$LATEST'
              )
          
            validateSuccess = output["AssociationDescription"]["Overview"]["Status"]
              
            if (validateSuccess == 'Success'):
              log = f"STEP STATUS: SUCCESS!\nTHE restartAllServices ({associationID}) ASSOCIATION WAS RUN SUCCESSFULLY!"
            elif (validateSuccess == 'Pending'):
              log = f"STEP STATUS: IN PROGRESS!\nTHE ASSOCIATION IS STILL IN PROGRESS. MAKE SURE TO CHECK THE restartAllServices ({associationID}) ASSOCIATION IN MICROSERVICE-QA TO CONFIRM IT COMPLETES SUCCESSFULLY."
          except:
            log = f"STEP STATUS: UNKNOWN!\nERROR CODE: 7B\nASSOCIATION ID: {associationID}\nTHERE WAS AN ISSUE RETRIEVING OUTPUTS FROM THE ASSOCIATION. THIS DOES NOT MEAN THAT THE COMMANDS WERE NOT RUN.\n{wiki}"
            
          failoverLog.append("\n" + log)
          return {'FAILOVER_LOG': failoverLog}

      InputPayload:
        standby_region: '{{retrieveRegions.STANDBY_REGION}}'
        date_time: '{{retrieveRegions.DATE_TIME}}'
        wikiLink: '{{retrieveRegions.WIKI_LINK}}'
        failoverLog: '{{restartMenuCollectorServices.FAILOVER_LOG}}'
    description: Restarting all services on the new primary stack to ensure they have loaded the latest configuration from the database
    outputs:
      - Name: FAILOVER_LOG
        Selector: $.Payload.FAILOVER_LOG
        Type: StringList



# ----------------------------------------------------------------------------------------------------------------------------------------------------



  - name: switchDNS
    action: 'aws:executeScript'
    inputs:
      Runtime: python3.6
      Handler: switch_DNS
      Script: |-

        import boto3
        import botocore
        from datetime import datetime

        def switch_DNS(event,context):
          
          #variables
          failoverLog = event['failoverLog']
          failoverLog.append("STEP: switchDNS\n")
          wiki = event['wikiLink']
          active_region=event['region']
          standby_region = event['standby_region']
          dt_raw = datetime.now()
          print_datetime = dt_raw.strftime("%m/%d/%Y %H:%M:%S")
          zoneId='genericHostedZoneID' #zone ID for MICROSERVICE-QA
          targetRecord=["MICROSERVICE1.companyNameqa.net","MICROSERVICE2.companyNameqa.net","MICROSERVICE3.companyNameqa.net","MICROSERVICE4.companyNameqa.net"] #target dns record to my modified
          
          #setting var for new endpoint depending on active region
          if (active_region == 'us-east-1'):
            rgn='west' #west dns record
            Listener_ARN = 'arn:aws:elasticloadbalancing:us-west-2:AWSACCOUNT#:listener/app/qa/' #west LB listener ARN
          elif (active_region == 'us-west-2'):
            rgn='east' #east dns record
            Listener_ARN = 'arn:aws:elasticloadbalancing:us-east-1:AWSACCOUNT#:listener/app/qa/' #east LB listener ARN
          endpoint=[f"MICROSERVICE1-{rgn}.companyNameqa.net",f"MICROSERVICE2-{rgn}.companyNameqa.net",f"MICROSERVICE3-{rgn}.companyNameqa.net",f"MICROSERVICE4-{rgn}.companyNameqa.net"]
          successCounter = 0
          
          client = boto3.client('elbv2', region_name = standby_region)
          
          #updates port on listener to 443 for new active region anyways
          failoverLog.append(f"UPDATING PORT ON THE {standby_region} (NEW ACTIVE REGION) TO 443 BEFORE SWITCHING DNS JUST IN CASE...")
          response = client.modify_listener(
            Port=443,
            ListenerArn=Listener_ARN,
          )

          #checking change to port
          response_check = client.describe_listeners(
            ListenerArns=[
              Listener_ARN,
              ],
            )
            
          port_after_change = response_check["Listeners"][0]["Port"]
          
          boto_sts=boto3.client('sts')
          
          #assuming role in aws_account_name
          stsresponse = boto_sts.assume_role(
            RoleArn="arn:aws:iam::AWSACCOUNT#:role/MICROSERVICE_FAILOVER_ROLE",
            RoleSessionName='switchDNS'
          )
          
          newsession_id = stsresponse["Credentials"]["AccessKeyId"]
          newsession_key = stsresponse["Credentials"]["SecretAccessKey"]
          newsession_token = stsresponse["Credentials"]["SessionToken"]

          client = boto3.client(
            'route53',
            aws_access_key_id=newsession_id,
            aws_secret_access_key=newsession_key,
            aws_session_token=newsession_token
          )
          
          #updates the route53 endpoint to the standby regions endpoint
          failoverLog.append("UPDATING DNS RECORDS IN ROUTE53...\n\n")
          for i in range(len(targetRecord)):
            response = client.change_resource_record_sets(
              ChangeBatch={
                'Changes': [
                  {
                    'Action': 'UPSERT',
                    'ResourceRecordSet': {
                    'Name': targetRecord[i],
                    'ResourceRecords': [
                      {
                        'Value': endpoint[i],
                      },
                    ],
                    'TTL': 60,
                    'Type': 'CNAME',
                    },
                  },
                ],
                'Comment': 'MICROSERVICEFAILOVER',
              },
              HostedZoneId=zoneId,
            )
          
          #posts slack notification
          slack = event['SlackChannel']
          snsclient = boto3.client('sns')
          snsArn = 'arn:aws:sns:us-east-1:AWSACCOUNT#:MICROSERVICE_FAILOVER_NOTIF'
          message = f"FAILOVER END TIME: {print_datetime}\nCHANNEL: {slack}"
          
          try:
            response = snsclient.publish(
              TopicArn = snsArn,
              Message = message,
              MessageAttributes={
                'Channel': {
                  'DataType': 'String',
                  'StringValue': f"{slack}"
                }
              },
              Subject = f"MICROSERVICE QA FAILOVER COMPLETE. THE DNS HAS BEEN SWITCHED. WE ARE NOW IN {standby_region}"
            )
          except:
            print("UNABLE TO POST TO SLACK.")
          
          #checks route53 record after upsert
          outputArray = []
          try:
            for x in range(len(targetRecord)):
              check_response = client.list_resource_record_sets(
                HostedZoneId=zoneId,
                StartRecordName=targetRecord[x],
                StartRecordType='CNAME',
                MaxItems='1'
              )
            
              #parsing response check
              recordName = check_response["ResourceRecordSets"][0]["Name"]
              recordEndpoint = check_response["ResourceRecordSets"][0]["ResourceRecords"][0]["Value"]
              
              
              if (recordEndpoint == endpoint[x]):
                successCounter += 1
                failoverLog.append("THE RECORD " + recordName + " IS NOW POINTED TO THE " + recordEndpoint + " ENDPOINT.\n")
            
            #--- validate step success ---
            if ((successCounter == len(targetRecord)) and (port_after_change == 443)):
              log = f"STEP STATUS: SUCCESS!\n{successCounter} OF {len(targetRecord)} RECORDS ARE POINTED TO THE CORRECT ENDPOINT AND THE LOAD BALANCER PORT IS 443."
            elif (successCounter != len(targetRecord)):
              log = f"STEP STATUS: FAILED!\nERROR CODE: 8A\nONLY {successCounter} OF {len(targetRecord)} RECORDS ARE POINTED TO THE CORRECT ENDPOINT. PLEASE CHECK ALL ENDPOINTS IN ROUTE53.\n{wiki}"
            elif (port_after_change != 443):
              log = f"STEP STATUS: FAILED!\nERROR CODE: 12A\nTHE PORT ON THE NEW ACTIVE REGION LOAD BALANCER LISTENER IS NOT 443!\nYOU MAY HAVE TO MANUALLY RESTORE THIS CONNECTION.\n{wiki}"
          except:
            log = f"STEP STATUS: UNKNOWN!\nERROR CODE: 8B\nTHERE WAS AN ISSUE PARSING OUTPUTS AND VALIDATING SUCCESS. THIS DOES NOT MEAN THAT THE DNS RECORDS WERE NOT UPDATED. PLEASE MANUALLY CHECK THE ENDPOINTS IN ROUTE53 TO CONFIRM THAT IT HAS BEEN UPDATED.\n{wiki}"
          
          failoverLog.append("\n" + log)
          return {'FAILOVER_LOG': failoverLog}
          
      InputPayload:
        region: '{{retrieveRegions.ACTIVE_REGION}}'
        standby_region: '{{retrieveRegions.STANDBY_REGION}}'
        SlackChannel: '{{SlackChannel}}'
        wikiLink: '{{retrieveRegions.WIKI_LINK}}'
        failoverLog: '{{restartAllServices.FAILOVER_LOG}}'
    description: 'Switches the Route53 endpoints'
    outputs:
      - Name: FAILOVER_LOG
        Selector: $.Payload.FAILOVER_LOG
        Type: StringList



# ----------------------------------------------------------------------------------------------------------------------------------------------------



  - name: changePort
    action: 'aws:executeScript'
    inputs:
      Runtime: python3.6
      Handler: changePort
      Script: |-

        import boto3
        import botocore

        def changePort(event,context):

          #variables
          failoverLog = event['failoverLog']
          failoverLog.append("STEP: changePort\n")
          wiki = event['wikiLink']
          active_region=event['region']
          if (active_region == 'us-east-1'):
            Listener_ARN = 'arn:aws:elasticloadbalancing:us-east-1:AWSACCOUNT#:listener/app/qa/' #east LB listener ARN
          elif (active_region == 'us-west-2'):
            Listener_ARN = 'arn:aws:elasticloadbalancing:us-west-2:AWSACCOUNT#:listener/app/qa/' #west LB listener ARN
            
          client = boto3.client('elbv2', region_name = active_region)
          
          #updates port on listener from 443 to 4443 for the active region
          failoverLog.append(f"UPDATING PORT ON THE {active_region} LOAD BALANCER TO TEMPORARILY BREAK THE CONNECTION USED BY partner3...")
          response = client.modify_listener(
            Port=4443,
            ListenerArn=Listener_ARN,
          )
          
          #checking change to port
          response_check = client.describe_listeners(
            ListenerArns=[Listener_ARN]
            )
          
          #parsing response check
          port_after_change = response_check["Listeners"][0]["Port"]
          
          #--- validate step success ---
          try:
            if (port_after_change == 4443):
              log = "STEP STATUS: SUCCESS!\nTHE PORT ON THE LISTENER HAS BEEN UPDATED TO: 4443"
            elif (port_after_change == 443):
              log = f"STEP STATUS: FAILED!\nERROR CODE: 9A\nTHE PORT ON THE LISTENER IS STILL 443\nYOU MAY HAVE TO MANUALLY BREAK THIS CONNECTION.\n{wiki}"
            else:
              log = f"STEP STATUS: FAILED!\nERROR CODE: 9B\nTHE PORT ON THE LISTENER IS: {port_after_change}\nYOU MAY HAVE TO MANUALLY BREAK THIS CONNECTION.\n{wiki}"
          except:
            log = f"STEP STATUS: UNKNOWN!\nERROR CODE: 9C\nTHERE WAS AN ISSUE PARSING OUTPUTS AND VALIDATING SUCCESS. THIS DOES NOT MEAN THAT THE LISTENER WAS NOT UPDATED. PLEASE MANUALLY CHECK THE LISTENER ON THE LOADBALANCER ({Listener_ARN}) TO CONFIRM THAT IT HAS BEEN UPDATED.\n{wiki}"

          failoverLog.append("\n" + log)
          return {'FAILOVER_LOG': failoverLog}
          
      InputPayload:
        region: '{{retrieveRegions.ACTIVE_REGION}}'
        wikiLink: '{{retrieveRegions.WIKI_LINK}}'
        failoverLog: '{{switchDNS.FAILOVER_LOG}}'
    description: Changes the port on the load balancer listener from 443 to 4443
    outputs:
      - Name: FAILOVER_LOG
        Selector: $.Payload.FAILOVER_LOG
        Type: StringList



# ----------------------------------------------------------------------------------------------------------------------------------------------------



  - name: swapSecrets
    action: 'aws:executeScript'
    inputs:
      Runtime: python3.6
      Handler: swapSecrets
      Script: |-

        import boto3
        import json
        import botocore

        def swapSecrets(event,context):

          #variables
          failoverLog = event['failoverLog']
          failoverLog.append("STEP: swapSecrets\n")
          wiki = event['wikiLink']
          active_region = event['active_region']
          standby_region = event['standby_region']
          credsEast = event['credsEast'] 
          credsWest = event['credsWest']
          LM_API_ID = event['LM_API_ID']
          LM_API_KEY = event['LM_API_KEY']
          secret_arn = "arn:aws:secretsmanager:us-east-1:AWSACCOUNT#:secret:MICROSERVICE-QA-STACKS"
          
          session = boto3.session.Session()
          client = session.client(service_name='secretsmanager',region_name="us-east-1")
          
          #retrieves secret values before they are swapped
          try:
            get_secret_value_response_before = client.get_secret_value(SecretId=secret_arn)
          
            #sets secret values as vars before they are swapped  
            MICROSERVICE_secrets_before = json.loads(get_secret_value_response_before['SecretString'])
            active_region_before = MICROSERVICE_secrets_before['PRIMARY_MICROSERVICE_QA_STACK']
            standby_region_before = MICROSERVICE_secrets_before['STANDBY_MICROSERVICE_QA_STACK']
            
            #swaps east/west secret values for active and standby stacks in secrets manager
            if (active_region == 'us-east-1'):
              failoverLog.append('SETTING THE ACTIVE REGION TO WEST IN SECRETS MANAGER...\n')
              response = client.update_secret(
                SecretId=secret_arn, 
                KmsKeyId='arn:aws:kms:us-east-1:AWSACCOUNT#:key/123-456-789',
                SecretString=json.dumps({"PRIMARY_MICROSERVICE_QA_STACK":"WEST","STANDBY_MICROSERVICE_QA_STACK":"EAST","QA_MASTER_CONNECTION_EAST":credsEast,"QA_MASTER_CONNECTION_WEST":credsWest,"LM_API_ID":LM_API_ID,"LM_API_KEY":LM_API_KEY})
                )
            elif (active_region == 'us-west-2'):
              failoverLog.append('SETTING THE ACTIVE REGION TO EAST IN SECRETS MANAGER...\n')
              response = client.update_secret(
                SecretId=secret_arn,
                KmsKeyId='arn:aws:kms:us-east-1:AWSACCOUNT#:key/123-456-789',
                SecretString=json.dumps({"PRIMARY_MICROSERVICE_QA_STACK":"EAST","STANDBY_MICROSERVICE_QA_STACK":"WEST","QA_MASTER_CONNECTION_EAST":credsEast,"QA_MASTER_CONNECTION_WEST":credsWest,"LM_API_ID":LM_API_ID,"LM_API_KEY":LM_API_KEY})
                )
            
            #retrieves secret values after they are swapped
            try:
              get_secret_value_response = client.get_secret_value(
                SecretId=secret_arn
              )
            except ClientError as e:
              raise e
          
            #sets secret values as vars after they are swapped
            MICROSERVICE_secrets = json.loads(get_secret_value_response['SecretString'])
            active_region_after = MICROSERVICE_secrets['PRIMARY_MICROSERVICE_QA_STACK']
            standby_region_after = MICROSERVICE_secrets['STANDBY_MICROSERVICE_QA_STACK']
            
            #--- validate step success ---
            if ((active_region_before == standby_region_after) and (standby_region_before == active_region_after)):
              log = f"STEP STATUS: SUCCESS!\n\nThe regions in secrets manager BEFORE the failover:\nACTIVE = {active_region_before} | STANDBY = {standby_region_before}\n\nThe regions in secrets manager AFTER the failover:\nACTIVE = {active_region_after} | STANDBY = {standby_region_after}"
            elif ((active_region_before == active_region_after) and (standby_region_before == standby_region_after)):
              log = f"STEP STATUS: FAILED!\nERROR CODE: 11A\nTHE REGIONS ARE STILL THE SAME AS BEFORE!\n{wiki}"
            else:
              log = f"STEP STATUS: FAILED!\nERROR CODE: 11B\nTHE SECRET VALUES ARE NOT WHAT THEY ARE SUPPOSED TO BE.\n{wiki}"
          except:
            log = f"STEP STATUS: FAILED!\nERROR CODE: 11C\nFAILED TO SWAP REGIONS IN SECRETS MANAGER! THERE COULD BE AN ISSUE WITH THE US-EAST-1 REGION. PLEASE MANUALLY SWAP THE REGIONS IN aws_account_name SECRETS MANAGER.\n{wiki}"

          failoverLog.append("\n" + log)
          return {'FAILOVER_LOG': failoverLog}

      InputPayload:
        active_region: '{{retrieveRegions.ACTIVE_REGION}}'
        standby_region: '{{retrieveRegions.STANDBY_REGION}}'
        credsEast: '{{retrieveRegions.CREDS_EAST}}'
        credsWest: '{{retrieveRegions.CREDS_WEST}}'
        LM_API_ID: '{{retrieveRegions.LM_API_ID}}'
        LM_API_KEY: '{{retrieveRegions.LM_API_KEY}}'
        wikiLink: '{{retrieveRegions.WIKI_LINK}}'
        failoverLog: '{{changePort.FAILOVER_LOG}}'
    description: This swaps the active and standby region secrets in secrets manager
    outputs:
      - Name: FAILOVER_LOG
        Selector: $.Payload.FAILOVER_LOG
        Type: StringList



# ----------------------------------------------------------------------------------------------------------------------------------------------------



  - name: revertPort
    action: 'aws:executeScript'
    inputs:
      Runtime: python3.6
      Handler: revertPort
      Script: |

        import boto3
        import botocore

        def revertPort(event,context):

          #variables
          failoverLog = event['failoverLog']
          failoverLog.append("STEP: revertPort\n")
          wiki = event['wikiLink']
          active_region=event['region']
          if (active_region == 'us-east-1'):
            Listener_ARN = 'arn:aws:elasticloadbalancing:us-east-1:AWSACCOUNT#:listener/app/qa/' #east LB listener ARN
          elif (active_region == 'us-west-2'):
            Listener_ARN = 'arn:aws:elasticloadbalancing:us-west-2:AWSACCOUNT#:listener/app/qa/' #west LB listener ARN
            
          client = boto3.client('elbv2', region_name = active_region)
          
          #updates port on listener from 4443 to 443 for the active region
          failoverLog.append(f"UPDATING PORT ON THE {active_region} LOAD BALANCER TO RESTORE THE CONNECTION USED BY partner3...")
          response = client.modify_listener(
            Port=443,
            ListenerArn=Listener_ARN,
          )
          
          #checking change to port
          response_check = client.describe_listeners(
            ListenerArns=[
              Listener_ARN,
              ],
            )
          
          #parsing response checks
          port_after_change = response_check["Listeners"][0]["Port"]
          
          #--- validate step success ---
          try:
            if (port_after_change == 443):
              log = "STEP STATUS: SUCCESS!\nTHE PORT ON THE LISTENER HAS BEEN UPDATED TO: 443"
            elif (port_after_change == 4443):
              log = f"STEP STATUS: FAILED!\nERROR CODE: 12A\nTHE PORT ON ONE OF THE LISTENERS IS STILL: 4443\nYOU MAY HAVE TO MANUALLY RESTORE THIS CONNECTION.\n{wiki}"
            else:
              log = f"STEP STATUS: FAILED!\nERROR CODE: 12B\nTHE PORT ON THE LISTENER IS AN UNKNOWN VALUE: {port_after_change}\nYOU MAY HAVE TO MANUALLY RESTORE THIS CONNECTION.\n{wiki}"
          except:
            log = f"STEP STATUS: UNKNOWN!\nERROR CODE: 12C\nTHERE WAS AN ISSUE PARSING OUTPUTS AND VALIDATING SUCCESS. THIS DOES NOT MEAN THAT THE LISTENER WAS NOT UPDATED. PLEASE MANUALLY CHECK THE LISTENER ON THE LOADBALANCER ({Listener_ARN}) TO CONFIRM THAT IT HAS BEEN UPDATED.\n{wiki}"

          failoverLog.append("\n" + log)
          return {'FAILOVER_LOG': failoverLog}

      InputPayload:
        region: '{{retrieveRegions.ACTIVE_REGION}}'
        wikiLink: '{{retrieveRegions.WIKI_LINK}}'
        failoverLog: '{{swapSecrets.FAILOVER_LOG}}'
    description: Reverts the port on the load balancer listener back 443 to re-establish the connection used by partners.
    outputs:
      - Name: FAILOVER_LOG
        Selector: $.Payload.FAILOVER_LOG
        Type: StringList



# ----------------------------------------------------------------------------------------------------------------------------------------------------



  - name: postLog
    action: 'aws:executeScript'
    inputs:
      Runtime: python3.6
      Handler: postLog
      Script: |

        import boto3
        import botocore
        import datetime

        def postLog(event,context):
          
          #variables
          lineBreak = "\n\n🔷➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖🔷\n\n"
          stepBreak =  "\n-- -- -- -- -- -- -- -- -- -- --\n"
          failoverLog = event['failoverLog'] 
          printFailoverLog = ""
          
          #adds emojies to log based on step status
          for f in failoverLog:
            if "STEP:" in f:
              printFailoverLog += lineBreak
              printFailoverLog += f
            elif "STEP STATUS: S" in f:
              printFailoverLog += f"{stepBreak} ✅ "
              printFailoverLog += f
            elif "STEP STATUS: F" in f:
              printFailoverLog += f"{stepBreak} ❌ "
              printFailoverLog += f
            elif "STEP STATUS: I" in f:
              printFailoverLog += f"{stepBreak} ⏳ "
              printFailoverLog += f
            elif "STEP STATUS: U" in f:
              printFailoverLog += "{stepBreak} ❓ " 
              printFailoverLog += f
            else:
              printFailoverLog += f


          printFailoverLog += "\n\n\n🔔 REMINDER: PERFORM QA TESTING AND REMEMBER TO APPROVE POST ACTIONS AFTERWARDS. 🔔"

          #post to slack  
          boto_sts=boto3.client('sts')
          
          #assuming role in aws_account_name
          stsresponse = boto_sts.assume_role(
            RoleArn="arn:aws:iam::AWSACCOUNT#:role/MICROSERVICE_FAILOVER_ROLE",
            RoleSessionName='switchDNS'
          )
          
          newsession_id = stsresponse["Credentials"]["AccessKeyId"]
          newsession_key = stsresponse["Credentials"]["SecretAccessKey"]
          newsession_token = stsresponse["Credentials"]["SessionToken"]

          client = boto3.client(
            'route53',
            aws_access_key_id=newsession_id,
            aws_secret_access_key=newsession_key,
            aws_session_token=newsession_token
          )
          

          #sends log to slack
          slack = 'alerts-testing'
          snsclient = boto3.client('sns')
          snsArn = 'arn:aws:sns:us-east-1:AWSACCOUNT#:MICROSERVICE_FAILOVER_NOTIF'
          message = printFailoverLog
          
          try:
            response = snsclient.publish(
              TopicArn = snsArn,
              Message = message,
              MessageAttributes={
                'Channel': {
                  'DataType': 'String',
                  'StringValue': slack
                }
              },
              Subject = "POST MICROSERVICE FAILOVER LOG"
            )
            
          except:
            print("UNABLE TO POST TO SLACK.")

      InputPayload:
        failoverLog: '{{revertPort.FAILOVER_LOG}}'
    description: ''



# ----------------------------------------------------------------------------------------------------------------------------------------------------



  - name: approvePostActions
    action: 'aws:approve'
    inputs:
      Approvers:
        - 'arn:aws:sts::AWS_ACCOUNT_NUMBER:assumed-role/PermissionSet/User@generic.com'
        - 'arn:aws:sts::AWS_ACCOUNT_NUMBER:assumed-role/PermissionSet/User@generic.com'
        - 'arn:aws:sts::AWS_ACCOUNT_NUMBER:assumed-role/PermissionSet/User@generic.com'
        - 'arn:aws:sts::AWS_ACCOUNT_NUMBER:assumed-role/PermissionSet/User@generic.com'
        - 'arn:aws:sts::AWS_ACCOUNT_NUMBER:assumed-role/PermissionSet/User@generic.com'
        - 'arn:aws:sts::AWS_ACCOUNT_NUMBER:assumed-role/PermissionSet/User@generic.com'
        - 'arn:aws:sts::AWS_ACCOUNT_NUMBER:assumed-role/PermissionSet/User@generic.com'
        - 'arn:aws:sts::AWS_ACCOUNT_NUMBER:assumed-role/PermissionSet/User@generic.com'
        - 'arn:aws:sts::AWS_ACCOUNT_NUMBER:assumed-role/PermissionSet/User@generic.com'
        - 'arn:aws:sts::AWS_ACCOUNT_NUMBER:assumed-role/PermissionSet/User@generic.com'
    description: 'Please use this step to confirm that the failover to the standby region has completed successfully. Once you have confirmed, please navigate to the target aws account and approve the post-actions from there.'



# ----------------------------------------------------------------------------------------------------------------------------------------------------



  - name: stopServicesNewStandby
    action: 'aws:executeScript'
    inputs:
      Runtime: python3.6
      Handler: stopServicesNewStandby
      Script: |-

        import boto3
        import botocore
        import time
        import re
        from datetime import datetime

        def stopServicesNewStandby(event,context):

          #variables
          wiki = event['wikiLink']
          dt_raw = datetime.now()
          date_time = dt_raw.strftime("%Y-%m-%dT%H:%M:00Z")
          active_region=event['active_region']
          if (active_region == 'us-east-1'):
            associationID = "associationID" #stopServicesNewStandby association in East
            startAgain = "associationID" #startServicesNewStandby association in East. (only used for testing. this portion should be hashed out.)
            instanceList = ["InstanceId","InstanceId","InstanceId","InstanceId","InstanceId","InstanceId","InstanceId"] #MICROSERVICE_QA_APPLICATION_INSTANCES_EAST
          elif (active_region == 'us-west-2'):
            associationID = "associationID" #stopServicesNewStandby association in West
            startAgain = "associationID" #startServicesNewStandby association in West. (only used for testing. this portion should be hashed out.)
            instanceList = ["InstanceId","InstanceId","InstanceId","InstanceId","InstanceId","InstanceId","InstanceId"] #MICROSERVICE_QA_APPLICATION_INSTANCES_WEST
          successCounter = 0
          
          client = boto3.client(service_name='ssm',region_name=active_region)
          
          response = client.start_associations_once(
            AssociationIds=[associationID]
            )
          
          time.sleep(20)
          
          #getting the command ID
          getCommandId = client.list_command_invocations(
            InstanceId=instanceList[0],
            Filters=[
                {
                  'key': 'InvokedAfter',
                  'value': date_time
                }
              ],
            )
          
          #running another association to start the MICROSERVICE processes again -- QA ONLY
          response = client.start_associations_once(
            AssociationIds=[
              startAgain
              ]
            )
            
          #parsing the command ID
          try:
            command_ID = getCommandId["CommandInvocations"][0]["CommandId"]
            
            #getting association output from instances
            associationOutputs = []
            for i in range(len(instanceList)):
              associationOutput = client.get_command_invocation(
                CommandId=command_ID,
                InstanceId=instanceList[i],
              )
              associationOutputs.append(associationOutput)
          
            #parsing association output from instances
            for x in range(len(associationOutputs)):
              parseAssociationOutput = re.search(r"'StandardOutputContent': '(.*)', 'StandardOutputUrl':", str(associationOutputs[x]))
              if re.search(r"\bApplying action stopProcessId\b", str(associationOutputs[x])):
                successCounter += 1
            

            #--- validate step success ---
            failoverLog.append("\n-- -- -- -- -- -- -- -- -- -- --\n")
            if (successCounter == len(instanceList)):
              print(f"STEP STATUS: SUCCESS!\n{successCounter} OF {len(instanceList)} INSTANCES SUCCESSFULLY RAN THE stopServicesNewStandby ({associationID}) ASSOCIATION.")
            elif (successCounter != len(instanceList)):
              print(f"STEP STATUS: FAILED!\nERROR CODE: 14A\nONLY {successCounter} OF {len(instanceList)} INSTANCES WERE ABLE TO RUN THE stopServicesNewStandby ({associationID}) ASSOCIATION. PLEASE CHECK EACH APPLICATION INSTANCE MANUALLY.\n{wiki}")
          except AttributeError:
            print('THERE WAS AN ISSUE RETRIEVING OUTPUTS FROM THE ASSOCIATION. CHECKING ASSOCIATION STATUS...')
            #if unable to grab or parse commandID, grabs association details
            output = client.describe_association(
              AssociationId=associationID,
              AssociationVersion='$LATEST'
              )
          
            validateSuccess = output["AssociationDescription"]["Overview"]["Status"]
            
            if (validateSuccess == 'Success'):
              print(f"STEP STATUS: SUCCESS!\nTHE stopServicesNewStandby ({associationID}) ASSOCIATION WAS RUN SUCCESSFULLY!")
            elif (validateSuccess == 'Pending'):
              print(f"STEP STATUS: IN PROGRESS!\nTHE ASSOCIATION IS STILL IN PROGRESS. MAKE SURE TO CHECK THE stopServicesNewStandby ({associationID}) ASSOCIATION IN MICROSERVICE-QA TO CONFIRM IT COMPLETES SUCCESSFULLY.")
          except:
            print(f"STEP STATUS: UNKNOWN!\nERROR CODE: 14B\nASSOCIATION ID: {associationID}\nTHERE WAS AN ISSUE RETRIEVING OUTPUTS FROM THE ASSOCIATION. THIS DOES NOT MEAN THAT THE COMMANDS WERE NOT RUN.\n{wiki}")


      InputPayload:
        active_region: '{{retrieveRegions.ACTIVE_REGION}}'
        date_time: '{{retrieveRegions.DATE_TIME}}'
        wikiLink: '{{retrieveRegions.WIKI_LINK}}'
    description: Stops all of the services on the new standby stack



# ----------------------------------------------------------------------------------------------------------------------------------------------------



  - name: downsizeNewStandby
    action: 'aws:executeScript'
    description: Scales down the new standby region
    inputs:
      Runtime: python3.6
      Handler: modify_instance_type
      Script: |-

        import boto3
        import botocore
        import re

        def modify_instance_type(event,context):
          
          wiki = event['wikiLink']
          active_region = event['region']
          instanceType = 'db.t4g.medium' #instance type to upsize to
          successCounter = 0
          responseOutputs = []
          if (active_region == 'us-west-2'):
            nodeList = ["QA-MICROSERVICE-db-node-0"] #docDB nodes in us-west-2
          elif (active_region == 'us-east-1'):
            nodeList = ["QA-MICROSERVICE-db-node-0","QA-MICROSERVICE-db-node-1","QA-MICROSERVICE-db-node-2"] #docDB nodes in us-east-1
          
          client = boto3.client('docdb',region_name=active_region)
          

          for x in range(len(nodeList)):
            response = client.modify_db_instance(
              DBInstanceIdentifier=nodeList[x],
              DBInstanceClass=instanceType,
              ApplyImmediately=True,
              )
            responseOutputs.append(response)
          
          
          #parsing response output from instances
          for i in range(len(responseOutputs)):
            try:
              parseResponseOutput = responseOutputs[i]["DBInstance"]["PendingModifiedValues"]["DBInstanceClass"]
              if (parseResponseOutput == instanceType):
                successCounter += 1
            except AttributeError:
              if re.search(r"\b'PendingModifiedValues': {'DBInstanceClass': 'db.t4g.medium'}\b", str(responseOutputs[i])):
                successCounter += 1
            except:
              print(f"THERE WAS AN ISSUE VALIDATING SUCCESS FOR {nodeList[i]}.")
          
          if (successCounter == len(nodeList)):
            print(f"STEP STATUS: SUCCESS!\n{successCounter} OF {len(nodeList)} NODES HAVE SUCCESSFULLY BEEN SENT THE REQUEST TO DOWNSIZE.")
          elif (successCounter != len(nodeList)):
            print(f"STEP STATUS: FAILED!\nERROR CODE: 15A\nONLY {successCounter} OF {len(nodeList)} NODES WERE SENT THE REQUEST TO DOWNSIZE.\nNOTE: THE INSTANCES COULD ALREADY BE SCALED DOWN. PLEASE CHECK THE DOCDB NODES IN {active_region} TO CONFIRM THEY ARE SCALED DOWN.\n{wiki}")
          else:
            print(f"STEP STATUS: UNKNOWN!\nERROR CODE: 15B\nTHERE WAS AN ISSUE RETRIEVING OUTPUTS FROM THE MODIFY DOCDB REQUESTS. THIS DOES NOT MEAN THE REQUESTS WERE NOT SENT, PLEASE CHECK THE DOCDB NODES IN {active_region} TO CONFIRM THEY ARE IN A MODIFYING STATE.\n{wiki}")
  
          
      InputPayload:
        region: '{{retrieveRegions.ACTIVE_REGION}}'
        wikiLink: '{{retrieveRegions.WIKI_LINK}}'
