description: |-
  # ** LOWER_ENVIRONMENT Disaster_Recovery**  

  --
  ## INSTRUCTIONS FOR RUNNING AUTOMATION


  1. *Click on "Execute Automation" in the top right corner.*
  2. *Choose Multi-Account and Region.*
  3. *For targets accounts, enter (account#) for LOWER_ENVIRONMENT.*
  4. *Set the region as us-east-1 OR us-west-2.*
  - **NOTE**: Do not choose more than one region, otherwise the automation will run twice.
  5. *Scroll down to the bottom and hit "Execute."*
  6. *Automation step Outputs can be seen by clicking "Automation" under "Change Management" on the left-hand toolbar, clicking on the execution ID of the automation running, clicking on the StepID, then the ExecutionID. Clicking on individual Step IDs after this will display the outputs of each step.



  Error Codes and Troubleshooting documention // [DOCUMENTATION_LINK_HERE]

  Further documentation regarding the automation // [DOCUMENTATION_LINK_HERE]
schemaVersion: '0.3'
assumeRole: '{{ AutomationAssumeRole }}'
parameters:
  AutomationAssumeRole:
    type: String
    description: The IAM role that runs the automation (DO NOT CHANGE.)
    allowedPattern: '^$|^arn:aws:iam::[0-9]*:role/[/\w+=,.@-]+$'
    default: 'arn:aws:iam::account#:role/AWS-SystemsManager-AutomationAdministrationRole'
  SlackChannel:
    type: String
    allowedValues:
      - slack1
      - slack2
      - slack3
      - slack4
    description: Specify which slack channel you would like to send the start and end notifications for this Disaster_Recovery automation.
    default: -slack1
mainSteps:
  - name: retrieveRegions
    action: 'aws:executeScript'
    inputs:
      Runtime: python3.6
      Handler: get_active_stack
      Script: |
        import sys
        import boto3
        import json
        import base64
        from datetime import datetime
        from botocore.exceptions import ClientError

        def get_active_stack(event,context):
          print("\n")
            
          region_east = event['REGION_EAST']
          region_west = event['REGION_WEST']
          dt_raw = datetime.now()
          current_datetime = dt_raw.strftime("%Y-%m-%dT%H:%M:00Z")
          print_datetime = dt_raw.strftime("%m/%d/%Y %H:%M:%S")
          
          #posts slack notification
          '''
          slack = event['SlackChannel']
          snsclient = boto3.client('sns')
          snsArn = 'arn:aws:sns:us-east-1:account#:_Disaster_Recovery_NOTIF'
          message = f"Disaster_Recovery START TIME: {print_datetime}\nCHANNEL: {slack}"
          
          try:
            if ((slack == 'slack1') or (slack == 'slack2') or (slack == 'slack3')):
              response = snsclient.publish(
                TopicArn = snsArn,
                Message = message,
                MessageAttributes={
                  'Channel': {
                    'microservice3Type': 'String',
                    'StringValue': f"{slack}"
                  }
                },
                Subject = " LOWER_ENVIRONMENT Disaster_Recovery HAS BEEN TRIGGERED."
              )
            elif (slack == 'slack4'):
              response = snsclient.publish(
                TopicArn = snsArn,
                Message = message,
                MessageAttributes={
                  'Channel': {
                    'microservice3Type': 'String',
                    'StringValue': f"{slack}"
                  }
                },
                Subject = " LOWER_ENVIRONMENT Disaster_Recovery TRIGGERED VIA ALARM. PLEASE NOTIFY @generic AND ALL RELEVANT RESOURCES."
              )
          except:
            print("UNABLE TO POST TO SLACK.") '''
          
          print(f"YOU HAVE CHOSEN TO RUN THE Disaster_Recovery IN LOWER_ENVIRONMENT...")

          #get the secret from us-east-1
          session = boto3.session.Session()
          try:
            secret_name = "arn:aws:secretsmanager:us-east-1:account#:secret:LOWER_ENVIRONMENT-STACKS"
          
            client = session.client(service_name='secretsmanager',region_name="us-east-1")
          
            get_secret_value_response = client.get_secret_value(SecretId=secret_name)
            
          #if failed to get secrets from us-east-1, try replica in us-west-2
          except:
            print("\nFAILED TO RETRIEVE SECRETS FROM US-EAST-1 !! RETRIEVING SECRETS FROM US-WEST-2...")
            secret_name = "arn:aws:secretsmanager:us-west-2:account#:secret:LOWER_ENVIRONMENT-STACKS"
          
            client = session.client(service_name='secretsmanager',region_name="us-west-2")
          
            get_secret_value_response = client.get_secret_value(SecretId=secret_name)
            
          #parsing secrets and saving them as vars
          _secrets = json.loads(get_secret_value_response['SecretString'])
          active_stack = _secrets['PRIMARY_LOWER_ENVIRONMENT_STACK'] #active region in secrets manager
          credentialsEast = _secrets['LOWER_ENVIRONMENT_MASTER_CONNECTION_EAST'] #docdb master credentials for the east region
          credentialsWest = _secrets['LOWER_ENVIRONMENT_MASTER_CONNECTION_WEST'] #docdb master credentials for the west region
          LM_API_ID = _secrets['LM_API_ID'] #logicmonitor API key
          LM_API_KEY = _secrets['LM_API_KEY'] #logicmonitor secret key
          
          if (active_stack == 'EAST'):
              active_region=region_east
              standby_region=region_west
          elif (active_stack == 'WEST'):
              active_region=region_west
              standby_region=region_east
          
          print("\n- - - - - - - - - - -\n")
          print(f"THE CURRENT ACTIVE REGION IN LOWER_ENVIRONMENT IS: {active_region}.")
          print(f"THE CURRENT STANDBY REGION IN LOWER_ENVIRONMENT IS: {standby_region}.")
          print(f"THE CURRENT DATE AND TIME IS: {print_datetime}.")
          print("\n- - - - - - - - - - -\n")
          
          return {'ACTIVE_REGION': active_region, 'STANDBY_REGION': standby_region, 'credentials_EAST': credentialsEast,'credentials_WEST': credentialsWest, 'LM_API_ID': LM_API_ID , 'LM_API_KEY': LM_API_KEY,'DATE_TIME': current_datetime}
      InputPayload:
        REGION_EAST: us-east-1
        REGION_WEST: us-west-2
        SlackChannel: '{{SlackChannel}}'
    outputs:
      - Name: ACTIVE_REGION
        Selector: $.Payload.ACTIVE_REGION
        Type: String
      - Name: STANDBY_REGION
        Selector: $.Payload.STANDBY_REGION
        Type: String
      - Name: credentials_EAST
        Selector: $.Payload.credentials_EAST
        Type: String
      - Name: credentials_WEST
        Selector: $.Payload.credentials_WEST
        Type: String
      - Name: LM_API_ID
        Selector: $.Payload.LM_API_ID
        Type: String
      - Name: LM_API_KEY
        Selector: $.Payload.LM_API_KEY
        Type: String
      - Name: DATE_TIME
        Selector: $.Payload.DATE_TIME
        Type: String
    description: Retrieves regions and credentials
  - name: upsizeStandby
    action: 'aws:executeScript'
    inputs:
      Runtime: python3.6
      Handler: modify_instance_type
      Script: |
        import boto3
        import json
        import botocore
        import sys
        import re

        def modify_instance_type(event,context):
          print("\n")
          
          standby_region = event['region']
          instanceType = 'db.r6g.large' #instance type to upsize to
          successCounter = 0
          responseOutputs = []
          if (standby_region == 'us-west-2'):
            nodeList = ["LOWER_ENVIRONMENT-db-node-0"] #docDB nodes in us-west-2
          elif (standby_region == 'us-east-1'):
            nodeList = ["LOWER_ENVIRONMENT-db-node-0","LOWER_ENVIRONMENT-db-node-1","LOWER_ENVIRONMENT-db-node-2"] #docDB nodes in us-east-1
          
          client = boto3.client('docdb',region_name=standby_region)
          
          #upsizes standby region nodes
          for x in range(len(nodeList)):
            response = client.modify_db_instance(
              DBInstanceIdentifier=f"{nodeList[x]}",
              DBInstanceClass=instanceType,
              ApplyImmediately=True,
              )
            responseOutputs.append(f"{response}")
            
          #parsing response output from instances
          for i in range(len(responseOutputs)):
            try:
              parseResponseOutput = re.search(r"'PendingModifiedValues': {'DBInstanceClass': '(.*)'}, 'EngineVersion':", str(responseOutputs[i]))
              if (parseResponseOutput.group(1) == instanceType):
                successCounter += 1
            except AttributeError:
              if re.search(r"\b'PendingModifiedValues': {'DBInstanceClass': 'db.r6g.large'}\b", str(responseOutputs[i])):
                successCounter += 1
            except:
              print(f"THERE WAS AN ISSUE VALIDATING SUCCESS FOR {nodeList[i]}.")
          
          if (successCounter == len(nodeList)):
            print("STEP STATUS: SUCCESS!")
            print(f"{successCounter} OF {len(nodeList)} NODES HAVE SUCCESSFULLY BEEN SENT THE REQUEST TO UPSIZE.\n")
          elif (successCounter != len(nodeList)):
            print("STEP STATUS: FAILED!\nERROR CODE: 2A")
            print(f"{successCounter} OF {len(nodeList)} NODES WERE SENT THE REQUEST TO UPSIZE.")
            print(f"NOTE: THE INSTANCES COULD ALREADY BE SCALED UP. PLEASE CHECK THE DOCDB NODES IN {standby_region} TO CONFIRM THEY ARE SCALED UP.\n")
            print("REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]")
          else:
            print("STEP STATUS: UNKNOWN!\nERROR CODE: 2B")
            print(f"THERE WAS AN ISSUE RETRIEVING OUTPUTS FROM THE MODIFY DOCDB REQUESTS. THIS DOES NOT MEAN THE REQUESTS WERE NOT SENT, PLEASE CHECK THE DOCDB NODES IN {standby_region} TO CONFIRM THEY ARE IN A MODIFYING STATE.\n")
            print("REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]")
      InputPayload:
        region: '{{retrieveRegions.STANDBY_REGION}}'
    description: Scales up the standby region
  - name: waitUntilStandbyIsUpsized
    action: 'aws:executeScript'
    inputs:
      Runtime: python3.6
      Handler: wait_instance_type
      Script: |-
        import boto3
        import json
        import botocore
        import sys
        import time

        def wait_instance_type(event,context):
          print("\n")
          
          time.sleep(60)
          
          standby_region = event['region']
          successCounter = 0
          if (standby_region == 'us-west-2'):
            nodeList = ["LOWER_ENVIRONMENT-db-node-0"] #docDB nodes in us-west-2
          elif (standby_region == 'us-east-1'):
            nodeList = ["LOWER_ENVIRONMENT-db-node-0","LOWER_ENVIRONMENT-db-node-1","LOWER_ENVIRONMENT-db-node-2"] #docDB nodes in us-east-1
          
          client = boto3.client('docdb',region_name=standby_region)
          
          waiter = client.get_waiter('db_instance_available')
          
          #waits until the docdb nodes are scaled up
          print("\n- - - - - - - - - - -\n")
          for x in range(len(nodeList)):
            waiter.wait(
              DBInstanceIdentifier=f"{nodeList[x]}",
              WaiterConfig={
                  'Delay': 60
              }
            )
            successCounter += 1
            print (f"WAIT COMPLETE FOR {nodeList[x]} IN {standby_region}.")
          print("\n- - - - - - - - - - -\n")
            
          #-- validate step success --
          if (successCounter == len(nodeList)):
            print("STEP STATUS: SUCCESS!")
            print(f"{successCounter} OF {len(nodeList)} NODES HAVE SUCCESSFULLY BEEN SCALED UP.\n")
          elif (successCounter != len(instanceList)):
            print("STEP STATUS: FAILED!\nERROR CODE: 3A")
            print(f"{successCounter} OF {len(nodeList)} NODES HAVE BEEN SCALED UP.\n")
            print("REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]")
          else:
            print("STEP STATUS: UNKNOWN!\nERROR CODE: 3B")
            print(f"THERE WAS AN ISSUE VALIDATING STEP SUCCESS. THIS DOES NOT MEAN THE DOCDB NODES ARE NOT SCALED UP. PLEASE CHECK THE DOCDB NODES IN {standby_region} TO CONFIRM THEY ARE SCALED UP.\n")
            print("REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]")
            
      InputPayload:
        region: '{{retrieveRegions.STANDBY_REGION}}'
    description: waits until the standby docdb nodes have reached an available state before moving forward
  - name: rundocumentDBQueriesActiveStack
    action: 'aws:executeScript'
    inputs:
      Runtime: python3.6
      Handler: rundocumentDBQueriesActiveStack
      Script: |-
        import boto3
        import json
        import botocore
        import sys
        import re

        def rundocumentDBQueriesActiveStack(event,context):
          print("\n")

          active_region=event['active_region']
          if (active_region == 'us-east-1'):
            credentials = event['credentialsEast'] #docdb master credentials for the east region
          elif (active_region == 'us-west-2'):
            credentials = event['credentialsWest'] #docdb master credentials for the west region
          lambdaPayload={"region":f"{active_region}","credentials":f"{credentials}","readOnly":"false"} #creates payload to be sent to lambda
          
          print (f"THE CURRENT ACTIVE REGION IS {active_region}.")
          print ("DISABLING service1, service2, AND service3 API CALLS IN THE DATABASE FOR THIS REGION...\n")

          #trigger lambda to run queries in DB
          client = boto3.client(service_name='lambda',region_name=active_region)
          response = client.invoke(
            FunctionName=f"arn:aws:lambda:{active_region}:account#:function:rundocumentDBQueries",
            InvocationType='RequestResponse',
            LogType='Tail',
            Payload=json.dumps(lambdaPayload)
            )
          
          #prints lambda output
          print("\n- - - - - - - - - - -\n")
          lambdaOutput = response['Payload']
          LO = lambdaOutput.read()
          LO_remove_backslash = str(LO).replace("\\","")
          LO_parsed = str(LO_remove_backslash).split(",")
          print ("THE NEW VALUES FROM THE DATABASE ARE AS FOLLOWS:\n")
          for x in LO_parsed:
            print (x)
          print("\n- - - - - - - - - - -\n")
          
          #microservice2 sync disabled parsing
          service1Check = re.search(r"{\\'microservice2SyncDisabled\\': (.*)}}]\"', ' \"service2\"", str(LO_parsed))

          #reports parsing
          service2ReportCheck = re.search(r"'sendToS3\\': (.*)}', \" 'site_status_report':", str(LO_parsed))
          statusReportCheck = re.search(r"{'sendToS3': (.*)}\", \" 'site_states_report':", str(LO_parsed))
          statesReportCheck = re.search(r"'site_states_report': {'sendToS3': (.*)}\", ' \\'site_status_events_report\\'", str(LO_parsed))
          statusEventsReportCheck = re.search(r"'site_status_events_report\\': {\\'sendToS3\\': (.*)}}}}]\"'", str(LO_parsed))

          #service3 partners config parsing
          shippingPartner1Check = re.search(r"{\\'shippingPartner1\\': {\\'apiInfo\\': {\\'fakeApi\\': (.*)}}', \"", str(LO_parsed))
          shippingPartner2Check = re.search(r"\" 'shippingPartner2': {'apiInfo': {'fakeApi': (.*)}}\", ' \\'shippingPartner3\\':", str(LO_parsed))
          shippingPartner3Check = re.search(r"'shippingPartner3\\': {\\'apiInfo\\': {\\'fakeApi\\': (.*)}}}}}]", str(LO_parsed))
          
          print("")
          try:
            if ((service1Check.group(1) == 'True') and (service2ReportCheck.group(1) == 'False') and (statusReportCheck.group(1) == 'False') and (statesReportCheck.group(1) == 'False') and (statusEventsReportCheck.group(1) == 'False') and (shippingPartner1Check.group(1) == 'True') and (shippingPartner2Check.group(1) == 'True') and (shippingPartner3Check.group(1) == 'True')):
              print("STEP STATUS: SUCCESS!")
            elif ((service1Check.group(1) == 'False') and (service2ReportCheck.group(1) == 'True') and (statusReportCheck.group(1) == 'True') and (statesReportCheck.group(1) == 'True') and (statusEventsReportCheck.group(1) == 'True') and (shippingPartner1Check.group(1) == 'False') and (shippingPartner2Check.group(1) == 'False') and (shippingPartner3Check.group(1) == 'False')):
              print("STEP STATUS: FAILED!\nERROR CODE: 4A")
              print("IT LOOKS LIKE THE VALUES FAILED TO UPDATE IN THE DATABASE. PLEASE SEE THE ERROR CODES DOCUMENTATION_LINK_HERE FOR MORE INFO: [DOCUMENTATION_LINK_HERE]")
            else:
              print("STEP STATUS: FAILED!\nERROR CODE: 4B")
              print("IT LOOKS LIKE SOME OF THE VALUES UPDATED AND SOME DIDN'T. PLEASE SEE THE ERROR CODES DOCUMENTATION_LINK_HERE FOR MORE INFO: [DOCUMENTATION_LINK_HERE]")
          except:
            print("STEP STATUS: UNKNOWN!\nERROR CODE: 4C")
            print("THERE WAS EITHER AN ISSUE TRIGGERING THE LAMBDA OR VALIDATING STEP SUCCESS. PLEASE REVIEW THE ABOVE OUTPUT FROM THE DATABASE IF IT EXISTS AND CONFIRM THE TRUE/FALSE VALUES FOLLOW THIS PATTERN:\nTRUE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE")
            print("REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]")
          print("")
              
      InputPayload:
        active_region: '{{retrieveRegions.ACTIVE_REGION}}'
        credentialsEast: '{{retrieveRegions.credentials_EAST}}'
        credentialsWest: '{{retrieveRegions.credentials_WEST}}'
    description: 'Disables service1, service2, and service3 API calls in the active region db'
  - name: rundocumentDBQueriesStandbyStack
    action: 'aws:executeScript'
    inputs:
      Runtime: python3.6
      Handler: rundocumentDBQueriesStandbyStack
      Script: |-
        import boto3
        import json
        import botocore
        import sys
        import re

        def rundocumentDBQueriesStandbyStack(event,context):
          print("\n")
          
          active_region=event['active_region']
          standby_region=event['standby_region']
          if (standby_region == 'us-east-1'):
            credentials = event['credentialsEast'] #docdb master credentials for the east region
          elif (standby_region == 'us-west-2'):
            credentials = event['credentialsWest'] #docdb master credentials for the west region
          lambdaPayload={"region":f"{active_region}","credentials":f"{credentials}","readOnly":"false"} #creates payload to be sent to lambda
          
          print (f"THE CURRENT STANDBY REGION IS {standby_region}.")
          print ("ENABLING service1, service2, AND service3 API CALLS IN THE DATABASE FOR THIS REGION...\n")

          #trigger lambda to run queries in DB
          client = boto3.client(service_name='lambda',region_name=standby_region)
          response = client.invoke(
            FunctionName=f"arn:aws:lambda:{standby_region}:account#:function:rundocumentDBQueries",
            InvocationType='RequestResponse',
            LogType='Tail',
            Payload=json.dumps(lambdaPayload)
            )
          
          #prints lambda output
          print("\n- - - - - - - - - - -\n")
          lambdaOutput = response['Payload']
          LO = lambdaOutput.read()
          LO_remove_backslash = str(LO).replace("\\","")
          LO_parsed = str(LO_remove_backslash).split(",")
          print ("THE NEW VALUES FROM THE DATABASE ARE AS FOLLOWS:")
          print("")
          for x in LO_parsed:
            print (x)
          print("\n- - - - - - - - - - -\n")
          
          #microservice2 sync disabled parsing
          service1Check = re.search(r"{\\'microservice2SyncDisabled\\': (.*)}}]\"', ' \"service2\"", str(LO_parsed))

          #reports parsing
          service2ReportCheck = re.search(r"'sendToS3\\': (.*)}', \" 'site_status_report':", str(LO_parsed))
          statusReportCheck = re.search(r"{'sendToS3': (.*)}\", \" 'site_states_report':", str(LO_parsed))
          statesReportCheck = re.search(r"'site_states_report': {'sendToS3': (.*)}\", ' \\'site_status_events_report\\'", str(LO_parsed))
          statusEventsReportCheck = re.search(r"'site_status_events_report\\': {\\'sendToS3\\': (.*)}}}}]\"'", str(LO_parsed))

          #service3 partners config parsing
          shippingPartner1Check = re.search(r"{\\'shippingPartner1\\': {\\'apiInfo\\': {\\'fakeApi\\': (.*)}}', \"", str(LO_parsed))
          shippingPartner2Check = re.search(r"\" 'shippingPartner2': {'apiInfo': {'fakeApi': (.*)}}\", ' \\'shippingPartner3\\':", str(LO_parsed))
          shippingPartner3Check = re.search(r"'shippingPartner3\\': {\\'apiInfo\\': {\\'fakeApi\\': (.*)}}}}}]", str(LO_parsed))
          
          print("")
          try:
            if ((service1Check.group(1) == 'False') and (service2ReportCheck.group(1) == 'True') and (statusReportCheck.group(1) == 'True') and (statesReportCheck.group(1) == 'True') and (statusEventsReportCheck.group(1) == 'True') and (shippingPartner1Check.group(1) == 'False') and (shippingPartner2Check.group(1) == 'False') and (shippingPartner3Check.group(1) == 'False')):
              print("STEP STATUS: SUCCESS!")
            elif ((service1Check.group(1) == 'True') and (service2ReportCheck.group(1) == 'False') and (statusReportCheck.group(1) == 'False') and (statesReportCheck.group(1) == 'False') and (statusEventsReportCheck.group(1) == 'False') and (shippingPartner1Check.group(1) == 'True') and (shippingPartner2Check.group(1) == 'True') and (shippingPartner3Check.group(1) == 'True')):
              print("STEP STATUS: FAILED!\nERROR CODE: 5A")
              print("IT LOOKS LIKE THE VALUES FAILED TO UPDATE IN THE DATABASE. REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]")
            else:
              print("STEP STATUS: FAILED!\nERROR CODE: 5B")
              print("IT LOOKS LIKE SOME OF THE VALUES UPDATED AND SOME DIDN'T. THIS MAY BE DUE TO THE LAMBDA READING FROM THE DATABASE BEFORE IT ACTUALLY UPDATED. REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]")
          except:
            print("STEP STATUS: UNKNOWN!\nERROR CODE: 5C")
            print("THERE WAS EITHER AN ISSUE TRIGGERING THE LAMBDA OR VALIDATING STEP SUCCESS. PLEASE REVIEW THE ABOVE OUTPUT FROM THE DATABASE IF IT EXISTS AND CONFIRM THE TRUE/FALSE VALUES FOLLOW THIS PATTERN:\nFALSE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE.")
            print("REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]")
          print("")
            
      InputPayload:
        active_region: '{{retrieveRegions.ACTIVE_REGION}}'
        standby_region: '{{retrieveRegions.STANDBY_REGION}}'
        credentialsEast: '{{retrieveRegions.credentials_EAST}}'
        credentialsWest: '{{retrieveRegions.credentials_WEST}}'
    description: |
      Enables service1, service2, and service3 API calls in the standby region db
  - name: restartMCServices
    action: 'aws:executeScript'
    inputs:
      Runtime: python3.6
      Handler: restartMCServices
      Script: "import boto3\nimport json\nimport botocore\nimport sys\nimport time\nimport re\n\ndef restartMCServices(event,context):\n  print(\"\\n\")\n  \n  date_time = event['date_time']\n  active_region=event['active_region']\n  if (active_region == 'us-east-1'):\n    associationID = \"associationID\" #restartMCServices association in East\n    instanceList = [\"instance1\",\"instance2\"] #_LOWER_ENVIRONMENT_microservice2_INSTANCES_EAST\n  elif (active_region == 'us-west-2'):\n    associationID\t= \"associationID\" #restartMCServices association in West\n    instanceList = [\"instance1\",\"instance2\"] #_LOWER_ENVIRONMENT_microservice2_INSTANCES_WEST\n  successCounter = 0\n  \n  client = boto3.client(service_name='ssm',region_name=active_region)\n  \n  response = client.start_associations_once(\n    AssociationIds=[\n      f\"{associationID}\"\n      ]\n    )\n\n  time.sleep(20)\n  \n  #getting the command ID\n  getCommandId = client.list_command_invocations(\n    InstanceId=f\"{instanceList[0]}\",\n    Filters=[\n        {\n          'key': 'InvokedAfter',\n          'value': f\"{date_time}\"\n        }\n      ],\n    )\n  \n  #parsing the command ID\n  parseCommandId = re.search(r\"'CommandId': '(.*)', 'InstanceId':\", str(getCommandId))\n  try:\n    command_ID = parseCommandId.group(1)\n  \n    #getting association output from instances\n    associationOutputs = []\n    for i in range(len(instanceList)):\n      associationOutput = client.get_command_invocation(\n        CommandId=f\"{command_ID}\",\n        InstanceId=f\"{instanceList[i]}\",\n      )\n      associationOutputs.append(f\"{associationOutput}\")\n  \n    #parsing association output from instances\n    for x in range(len(associationOutputs)):\n      print(\"-\" + instanceList[x] + \"-\")\n      parseAssociationOutput = re.search(r\"update-env to update environment variables(.*)', 'StandardOutputUrl':\", str(associationOutputs[x]))\n      print(parseAssociationOutput.group(1))\n      if re.search(r\"\\bApplying action restartProcessId\\b\", str(associationOutputs[x])):\n        successCounter += 1\n\n    print(\"\\n- - - - - - - - - - -\\n\")\n    if (successCounter == len(instanceList)):\n      print(\"STEP STATUS: SUCCESS!\")\n      print(f\"{successCounter} OF {len(instanceList)} INSTANCES SUCCESSFULLY RAN THE restartMCServices ({associationID}) ASSOCIATION.\")\n    elif (successCounter != len(instanceList)):\n      print(\"STEP STATUS: FAILED!\\nERROR CODE: 6A\")\n      print(f\"ONLY {successCounter} OF {len(instanceList)} INSTANCES WERE ABLE TO RUN THE restartMCServices ({associationID}) ASSOCIATION.\")\n      print(\"REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]\")\n  except AttributeError:\n    print('THERE WAS AN ISSUE RETRIEVING OUTPUTS FROM THE ASSOCIATION. CHECKING ASSOCIATION STATUS...')\n    #if unable to grab or parse commandID, grabs association details\n    output = client.describe_association(\n      AssociationId=f\"{associationID}\",\n      AssociationVersion='$LATEST'\n      )\n  \n    validateSuccess = re.search(\"'Status': '(.*)', 'DetailedStatus'\", str(output))\n    \n    if (validateSuccess.group(1) == 'Success'):\n      print(\"STEP STATUS: SUCCESS!\")\n      print(f\"THE restartMCServices ({associationID}) ASSOCIATION WAS RUN SUCCESSFULLY!\")\n    elif (validateSuccess.group(1) == 'Pending'):\n      print(\"STEP STATUS: IN PROGRESS!\")\n      print(f\"THE ASSOCIATION IS STILL IN PROGRESS. MAKE SURE TO CHECK THE restartMCServices ({associationID}) ASSOCIATION IN SERVICELOWER_ENVIRONMENT TO CONFIRM IT COMPLETES SUCCESSFULLY.\")\n  except:\n    print(\"STEP STATUS: UNKNOWN!\\nERROR CODE: 6B\")\n    print(f\"ASSOCIATION ID: {associationID}\")\n    print('THERE WAS AN ISSUE RETRIEVING OUTPUTS FROM THE ASSOCIATION. THIS DOES NOT MEAN THAT THE COMMANDS WERE NOT RUN.')\n    print(\"REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]\")\n  "
      InputPayload:
        active_region: '{{retrieveRegions.ACTIVE_REGION}}'
        date_time: '{{retrieveRegions.DATE_TIME}}'
    description: Restarting the microservice2 services on the current primary stack to honor the change of the microservice2SyncDisabled flag
  - name: restartAllServices
    action: 'aws:executeScript'
    inputs:
      Runtime: python3.6
      Handler: restartAllServices
      Script: "import boto3\nimport json\nimport botocore\nimport sys\nimport time\nimport re\n\ndef restartAllServices(event,context):\n  print(\"\\n\")\n\n  date_time = event['date_time']\n  standby_region=event['standby_region']\n  if (standby_region == 'us-east-1'):\n    associationID = \"associationID\" #restartAllServices association in East\n    instanceList = [\"instance1\",\"instance2\",\"instance3\",\"instance4\",\"instance5\",\"instance6\",\"instance7\"] #_LOWER_ENVIRONMENT_APPLICATION_INSTANCES_EAST\n  elif (standby_region == 'us-west-2'):\n    associationID\t= \"associationID\" #restartAllServices association in West\n    instanceList = [\"instance1\",\"instance2\",\"instance3\",\"instance4\",\"instance5\",\"instance6\",\"instance7\"] #_LOWER_ENVIRONMENT_APPLICATION_INSTANCES_WEST\n  successCounter = 0\n\n  client = boto3.client(service_name='ssm',region_name=standby_region)\n  \n  response = client.start_associations_once(\n    AssociationIds=[\n      f\"{associationID}\"\n      ]\n    )\n  \n  time.sleep(20)\n  \n  #getting the command ID\n  getCommandId = client.list_command_invocations(\n    InstanceId=f\"{instanceList[0]}\",\n    Filters=[\n        {\n          'key': 'InvokedAfter',\n          'value': f\"{date_time}\"\n        }\n      ],\n    )\n  \n  #parsing the command ID\n  parseCommandId = re.search(r\"'CommandId': '(.*)', 'InstanceId':\", str(getCommandId))\n  try:\n    command_ID = parseCommandId.group(1)\n  \n    #getting association output from instances\n    associationOutputs = []\n    for i in range(len(instanceList)):\n      associationOutput = client.get_command_invocation(\n        CommandId=f\"{command_ID}\",\n        InstanceId=f\"{instanceList[i]}\",\n      )\n      associationOutputs.append(f\"{associationOutput}\")\n  \n    #parsing association output from instances\n    for x in range(len(associationOutputs)):\n      print(\"-\" + instanceList[x] + \"-\")\n      parseAssociationOutput = re.search(r\"update-env to update environment variables(.*)', 'StandardOutputUrl':\", str(associationOutputs[x]))\n      print(parseAssociationOutput.group(1))\n      if re.search(r\"\\bApplying action restartProcessId\\b\", str(associationOutputs[x])):\n        successCounter += 1\n    \n    print(\"\\n- - - - - - - - - - -\\n\")\n    if (successCounter == len(instanceList)):\n      print(\"STEP STATUS: SUCCESS!\")\n      print(f\"{successCounter} OF {len(instanceList)} INSTANCES SUCCESSFULLY RAN THE restartAllServices ({associationID}) ASSOCIATION.\")\n    elif (successCounter != len(instanceList)):\n      print(\"STEP STATUS: FAILED!\\nERROR CODE: 7A\")\n      print(f\"ONLY {successCounter} OF {len(instanceList)} INSTANCES WERE ABLE TO RUN THE restartAllServices ({associationID}) ASSOCIATION. PLEASE CHECK EACH APPLICATION INSTANCE MANUALLY.\")\n      print(\"REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]\")\n  except AttributeError:\n    print('THERE WAS AN ISSUE RETRIEVING OUTPUTS FROM THE ASSOCIATION. CHECKING ASSOCIATION STATUS...')\n    #if unable to grab or parse commandID, grabs association details\n    output = client.describe_association(\n      AssociationId=f\"{associationID}\",\n      AssociationVersion='$LATEST'\n      )\n  \n    validateSuccess = re.search(\"'Status': '(.*)', 'DetailedStatus'\", str(output))\n    \n    if (validateSuccess.group(1) == 'Success'):\n      print(\"STEP STATUS: SUCCESS!\")\n      print(f\"THE restartAllServices ({associationID}) ASSOCIATION WAS RUN SUCCESSFULLY!\")\n    elif (validateSuccess.group(1) == 'Pending'):\n      print(\"STEP STATUS: IN PROGRESS!\")\n      print(f\"THE ASSOCIATION IS STILL IN PROGRESS. MAKE SURE TO CHECK THE restartAllServices ({associationID}) ASSOCIATION IN AWS-ACCOUNT TO CONFIRM IT COMPLETES SUCCESSFULLY.\")\n  except:\n    print(\"STEP STATUS: UNKNOWN!\\nERROR CODE: 7B\")\n    print(f\"ASSOCIATION ID: {associationID}\")\n    print('THERE WAS AN ISSUE RETRIEVING OUTPUTS FROM THE ASSOCIATION. THIS DOES NOT MEAN THAT THE COMMANDS WERE NOT RUN.')\n    print(\"REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]\")\n  "
      InputPayload:
        standby_region: '{{retrieveRegions.STANDBY_REGION}}'
        date_time: '{{retrieveRegions.DATE_TIME}}'
    description: Restarting all services on the new primary stack to ensure they have loaded the latest configuration
  - name: switchDNS
    action: 'aws:executeScript'
    inputs:
      Runtime: python3.6
      Handler: switch_DNS
      Script: |-
        import boto3
        import json
        import botocore
        import sys
        import re
        from datetime import datetime

        def switch_DNS(event,context):
          print("\n")
          
          active_region=event['region']
          standby_region = event['standby_region']
          dt_raw = datetime.now()
          print_datetime = dt_raw.strftime("%m/%d/%Y %H:%M:%S")
          zoneId='PLACEHOLDER' #zone ID for LOWER_ENVIRONMENT
          targetRecord=["microservice3.generic.net","microservice.generic.net","microservice2.generic.net","microservice1.generic.net"] #target dns record to my modified
          #setting var for new endpoint depending on active region
          if (active_region == 'us-east-1'):
            rgn='west' #west dns record
            Listener_ARN = 'arn:aws:elasticloadbalancing:us-west-2:account#:listener/app/microservice-lwrenv/' #west LB listener ARN
          elif (active_region == 'us-west-2'):
            rgn='east' #east dns record
            Listener_ARN = 'arn:aws:elasticloadbalancing:us-east-1:account#:listener/app/microservice-lwrenv/' #east LB listener ARN
          endpoint=[f"microservice3{rgn}.generic.net",f"microservice{rgn}.generic.net",f"microservice2{rgn}.generic.net",f"microservice1{rgn}.generic.net"]
          successCounter = 0
          
          client = boto3.client('elbv2', region_name = standby_region)
          
          #updates port on listener to 443 for new active region anyways
          print(f"UPDATING PORT ON THE {standby_region} (NEW ACTIVE REGION) TO 443 BEFORE SWITCHING DNS JUST IN CASE...")
          response = client.modify_listener(
            Port=443,
            ListenerArn=Listener_ARN,
          )

          #checking change to port
          response_check = client.describe_listeners(
            ListenerArns=[
              Listener_ARN,
              ],
            )
            
          port_after_change = re.search("'Port': (.*), 'Protocol'", str(response_check))
          
          boto_sts=boto3.client('sts')
          
          #assuming role in AWS-ACCOUNT
          stsresponse = boto_sts.assume_role(
            RoleArn="arn:aws:iam::account#:role/_Disaster_Recovery_ROLE",
            RoleSessionName='switchDNS'
          )
          
          newsession_id = stsresponse["Credentials"]["AccessKeyId"]
          newsession_key = stsresponse["Credentials"]["SecretAccessKey"]
          newsession_token = stsresponse["Credentials"]["SessionToken"]

          client = boto3.client(
            'route53',
            aws_access_key_id=newsession_id,
            aws_secret_access_key=newsession_key,
            aws_session_token=newsession_token
          )
          
          #updates the route53 endpoint to the standby regions endpoint
          print("UPDATING DNS RECORDS IN ROUTE53...\n")
          for i in range(len(targetRecord)):
            response = client.change_resource_record_sets(
              ChangeBatch={
                'Changes': [
                  {
                    'Action': 'UPSERT',
                    'ResourceRecordSet': {
                    'Name': f"{targetRecord[i]}",
                    'ResourceRecords': [
                      {
                        'Value': f"{endpoint[i]}",
                      },
                    ],
                    'TTL': 60,
                    'Type': 'CNAME',
                    },
                  },
                ],
                'Comment': 'Disaster_Recovery',
              },
              HostedZoneId=f"{zoneId}",
            )
          
          #posts slack notification
          '''
          slack = event['SlackChannel']
          snsclient = boto3.client('sns')
          snsArn = 'arn:aws:sns:us-east-1:account#:_Disaster_Recovery_NOTIF'
          message = f"Disaster_Recovery END TIME: {print_datetime}\nCHANNEL: {slack}"
          
          try:
            response = snsclient.publish(
              TopicArn = snsArn,
              Message = message,
              MessageAttributes={
                'Channel': {
                  'microservice3Type': 'String',
                  'StringValue': f"{slack}"
                }
              },
              Subject = f" LOWER_ENVIRONMENT Disaster_Recovery COMPLETE. THE DNS HAS BEEN SWITCHED. WE ARE NOW IN {standby_region}"
            )
          except:
            print("UNABLE TO POST TO SLACK.")'''
          
          #checks route53 record after upsert
          print("\n- - - - - - - - - - -\n")
          outputArray = []
          try:
            for x in range(len(targetRecord)):
              check_response = client.list_resource_record_sets(
                HostedZoneId=f"{zoneId}",
                StartRecordName=f"{targetRecord[x]}",
                StartRecordType='CNAME',
                MaxItems='1'
              )
            
              #parsing response check
              recordName = re.search("\[\{'Name': '(.*)', 'Type'", str(check_response))
              recordEndpoint = re.search("\[\{'Value': '(.*)'}]", str(check_response))
              
              if (recordEndpoint.group(1) == endpoint[x]):
                successCounter += 1
                print("THE RECORD " + recordName.group(1) + " IS NOW POINTED TO THE " + recordEndpoint.group(1) + " ENDPOINT.")
            
            print("\n- - - - - - - - - - -\n")
            
            if ((successCounter == len(targetRecord)) and (port_after_change.group(1) == '443')):
              print("STEP STATUS: SUCCESS!")
              print(f"{successCounter} OF {len(targetRecord)} RECORDS ARE POINTED TO THE CORRECT ENDPOINT AND THE LOAD BALANCER PORT IS 443.")
            elif (successCounter != len(targetRecord)):
              print("STEP STATUS: FAILED!\nERROR CODE: 8A")
              print(f"ONLY {successCounter} OF {len(targetRecord)} RECORDS ARE POINTED TO THE CORRECT ENDPOINT. PLEASE CHECK ALL ENDPOINTS IN ROUTE53.")
              print("REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]")
            elif (port_after_change.group(1) != '443'):
              print("STEP STATUS: FAILED!\nERROR CODE: 12A")
              print("THE PORT ON THE NEW ACTIVE REGION LOAD BALANCER LISTENER IS NOT 443!")
              print('YOU MAY HAVE TO MANUALLY RESET THIS CONNECTION. REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]')
          except:
            print("STEP STATUS: UNKNOWN!\nERROR CODE: 8B")
            print(f"THERE WAS AN ISSUE PARSING OUTPUTS AND VALIDATING SUCCESS. THIS DOES NOT MEAN THAT THE DNS RECORDS WERE NOT UPDATED. PLEASE MANUALLY CHECK THE ENDPOINTS (microservice, microservice1, microservice2, microservice3) IN ROUTE53 TO CONFIRM THAT IT HAS BEEN UPDATED.")
            print("REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]")
          print("")
          
      InputPayload:
        region: '{{retrieveRegions.ACTIVE_REGION}}'
        standby_region: '{{retrieveRegions.STANDBY_REGION}}'
        SlackChannel: '{{SlackChannel}}'
    description: 'Switches the Route53 microservice, microservice1, microservice2, and microservice3 endpoints'
  - name: changePort
    action: 'aws:executeScript'
    inputs:
      Runtime: python3.6
      Handler: changePort
      Script: |-
        import boto3
        import json
        import botocore
        import sys
        import re

        def changePort(event,context):
          print("\n")
          
          active_region=event['region']
          if (active_region == 'us-east-1'):
            Listener_ARN = 'arn:aws:elasticloadbalancing:us-east-1:account#:listener/app/microservice-lwrenv/' #east LB listener ARN
          elif (active_region == 'us-west-2'):
            Listener_ARN = 'arn:aws:elasticloadbalancing:us-west-2:account#:listener/app/microservice-lwrenv/' #west LB listener ARN
            
          client = boto3.client('elbv2', region_name = active_region)
          
          #updates port on listener from 443 to 4443 for the active region
          print(f"UPDATING PORT ON THE {active_region} LOAD BALANCER TO TEMPORARILY BREAK THE CONNECTION USED BY shippingPartner2...")
          response = client.modify_listener(
            Port=4443,
            ListenerArn=Listener_ARN,
          )
          
          #checking change to port
          response_check = client.describe_listeners(
            ListenerArns=[
              Listener_ARN,
              ],
            )
          
          #parsing response check
          port_after_change = re.search("'Port': (.*), 'Protocol'", str(response_check))
          
          print("\n- - - - - - - - - - -\n")
          try:
            if (port_after_change.group(1) == '4443'):
              print("STEP STATUS: SUCCESS!")
              print("THE PORT ON THE LISTENER HAS BEEN UPDATED TO: " + port_after_change.group(1))
            elif (port_after_change.group(1) == '443'):
              print("STEP STATUS: FAILED!\nERROR CODE: 9A")
              print("THE PORT ON THE LISTENER IS STILL " + port_after_change.group(1))
              print('YOU MAY HAVE TO MANUALLY BREAK THIS CONNECTION. REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]')
            else:
              print("STEP STATUS: FAILED!\nERROR CODE: 9B")
              print("THE PORT ON THE LISTENER IS: " + port_after_change.group(1))
              print('YOU MAY HAVE TO MANUALLY BREAK THIS CONNECTION. REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]')
          except:
            print("STEP STATUS: UNKNOWN!\nERROR CODE: 9C")
            print(f"THERE WAS AN ISSUE PARSING OUTPUTS AND VALIDATING SUCCESS. THIS DOES NOT MEAN THAT THE LISTENER WAS NOT UPDATED. PLEASE MANUALLY CHECK THE LISTENER ON THE LOADBALANCER ({Listener_ARN}) TO CONFIRM THAT IT HAS BEEN UPDATED.")
            print("REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]")
          print("")
          
      InputPayload:
        region: '{{retrieveRegions.ACTIVE_REGION}}'
    description: Changes the port on the -microservice load balancer listener from 443 to 4443
  - name: swapSecrets
    action: 'aws:executeScript'
    inputs:
      Runtime: python3.6
      Handler: swapSecrets
      Script: "import boto3\nimport json\nimport botocore\nimport sys\n\ndef swapSecrets(event,context):\n  print(\"\\n\")\n  \n  active_region = event['active_region']\n  standby_region = event['standby_region']\n  credentialsEast = event['credentialsEast'] \n  credentialsWest = event['credentialsWest']\n  LM_API_ID\t= event['LM_API_ID']\n  LM_API_KEY = event['LM_API_KEY']\n  secret_arn = \"arn:aws:secretsmanager:us-east-1:account#:secret:LOWER_ENVIRONMENT-STACKS\"\n  \n  session = boto3.session.Session()\n  client = session.client(service_name='secretsmanager',region_name=\"us-east-1\")\n  \n  #retrieves secret values before they are swapped\n  try:\n    get_secret_value_response_before = client.get_secret_value(SecretId=secret_arn)\n  \n    #sets secret values as vars before they are swapped  \n    _secrets_before = json.loads(get_secret_value_response_before['SecretString'])\n    active_region_before = _secrets_before['PRIMARY_LOWER_ENVIRONMENT_STACK']\n    standby_region_before = _secrets_before['STANDBY_LOWER_ENVIRONMENT_STACK']\n    \n    #swaps east/west secret values for active and standby stacks in secrets manager\n    if (active_region == 'us-east-1'):\n      print ('SETTING THE ACTIVE REGION TO WEST IN SECRETS MANAGER...\\n')\n      response = client.update_secret(\n        SecretId=secret_arn, \n        KmsKeyId='arn:aws:kms:us-east-1:account#:key/genericID',\n        SecretString=json.dumps({\"PRIMARY_LOWER_ENVIRONMENT_STACK\":\"WEST\",\"STANDBY_LOWER_ENVIRONMENT_STACK\":\"EAST\",\"LOWER_ENVIRONMENT_MASTER_CONNECTION_EAST\":credentialsEast,\"LOWER_ENVIRONMENT_MASTER_CONNECTION_WEST\":credentialsWest,\"LM_API_ID\":LM_API_ID,\"LM_API_KEY\":LM_API_KEY})\n        )\n    elif (active_region == 'us-west-2'):\n      print ('SETTING THE ACTIVE REGION TO EAST IN SECRETS MANAGER...\\n')\n      response = client.update_secret(\n        SecretId=secret_arn,\n        KmsKeyId='arn:aws:kms:us-east-1:account#:key/KMS_KEY_ID',\n        SecretString=json.dumps({\"PRIMARY_LOWER_ENVIRONMENT_STACK\":\"EAST\",\"STANDBY_LOWER_ENVIRONMENT_STACK\":\"WEST\",\"LOWER_ENVIRONMENT_MASTER_CONNECTION_EAST\":credentialsEast,\"LOWER_ENVIRONMENT_MASTER_CONNECTION_WEST\":credentialsWest,\"LM_API_ID\":LM_API_ID,\"LM_API_KEY\":LM_API_KEY})\n        )\n    \n    #retrieves secret values after they are swapped\n    try:\n      get_secret_value_response = client.get_secret_value(\n        SecretId=secret_arn\n      )\n    except ClientError as e:\n      raise e\n  \n    #sets secret values as vars after they are swapped\n    _secrets = json.loads(get_secret_value_response['SecretString'])\n    active_region_after = _secrets['PRIMARY_LOWER_ENVIRONMENT_STACK']\n    standby_region_after = _secrets['STANDBY_LOWER_ENVIRONMENT_STACK']\n    \n    if ((active_region_before == standby_region_after) and (standby_region_before == active_region_after)):\n      print(\"STEP STATUS: SUCCESS!\")\n      print(\"\\n- - - - - - - - - - -\\n\")\n      print(\"The regions in secrets manager BEFORE the Disaster_Recovery: \")\n      print(f\"ACTIVE = {active_region_before} | STANDBY = {standby_region_before}\\n\")\n      print(\"The regions in secrets manager AFTER the Disaster_Recovery: \")\n      print(f\"ACTIVE = {active_region_after} | STANDBY = {standby_region_after}\")\n    elif ((active_region_before == active_region_after) and (standby_region_before == standby_region_after)):\n      print(\"STEP STATUS: FAILED!\\nERROR CODE: 11A\")\n      print('THE REGIONS ARE STILL THE SAME AS BEFORE! REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]')\n    else:\n      print(\"STEP STATUS: FAILED!\\nERROR CODE: 11B\")\n      print('THE SECRET VALUES ARE NOT WHAT THEY ARE SUPPOSED TO BE. REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]')\n    print(\"\")\n  except:\n    print(\"STEP STATUS: FAILED!\\nERROR CODE: 11C\")\n    print(\"FAILED TO SWAP REGIONS IN SECRETS MANAGER! THERE COULD BE AN ISSUE WITH THE US-EAST-1 REGION. PLEASE MANUALLY SWAP THE REGIONS IN AWS-ACCOUNT SECRETS MANAGER:\")\n    print(\"REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]\")\n    "
      InputPayload:
        active_region: '{{retrieveRegions.ACTIVE_REGION}}'
        standby_region: '{{retrieveRegions.STANDBY_REGION}}'
        credentialsEast: '{{retrieveRegions.credentials_EAST}}'
        credentialsWest: '{{retrieveRegions.credentials_WEST}}'
        LM_API_ID: '{{retrieveRegions.LM_API_ID}}'
        LM_API_KEY: '{{retrieveRegions.LM_API_KEY}}'
    description: This swaps the active and standby region secrets in secrets manager
  - name: revertPort
    action: 'aws:executeScript'
    inputs:
      Runtime: python3.6
      Handler: revertPort
      Script: |
        import boto3
        import json
        import botocore
        import sys
        import re

        def revertPort(event,context):
          print("\n")
          
          active_region=event['region']
          if (active_region == 'us-east-1'):
            Listener_ARN = 'arn:aws:elasticloadbalancing:us-east-1:account#:listener/app/microservice-lwrenv/' #east LB listener ARN
          elif (active_region == 'us-west-2'):
            Listener_ARN = 'arn:aws:elasticloadbalancing:us-west-2:account#:listener/app/microservice-lwrenv/' #west LB listener ARN
            
          client = boto3.client('elbv2', region_name = active_region)
          
          #updates port on listener from 4443 to 443 for the active region
          print(f"UPDATING PORT ON THE {active_region} LOAD BALANCER TO RESET THE CONNECTION USED BY shippingPartner2...")
          response = client.modify_listener(
            Port=443,
            ListenerArn=Listener_ARN,
          )
          
          #checking change to port
          response_check = client.describe_listeners(
            ListenerArns=[
              Listener_ARN,
              ],
            )
          
          #parsing response checks
          port_after_change = re.search("'Port': (.*), 'Protocol'", str(response_check))
          
          print("\n- - - - - - - - - - -\n")
          try:
            if (port_after_change.group(1) == '443'):
              print("STEP STATUS: SUCCESS!")
              print("THE PORT ON THE LISTENER HAS BEEN UPDATED TO: 443")
            elif (port_after_change.group(1) == '4443'):
              print("STEP STATUS: FAILED!\nERROR CODE: 12A")
              print("THE PORT ON ONE OF THE LISTENERS IS STILL: 4443")
              print('YOU MAY HAVE TO MANUALLY RESET THIS CONNECTION. REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]')
            else:
              print("STEP STATUS: FAILED!\nERROR CODE: 12B")
              print("THE PORT ON THE LISTENER IS AN UNKNOWN VALUE.")
              print('YOU MAY HAVE TO MANUALLY RESET THIS CONNECTION. REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]')
          except:
            print("STEP STATUS: UNKNOWN!\nERROR CODE: 12C")
            print(f"THERE WAS AN ISSUE PARSING OUTPUTS AND VALIDATING SUCCESS. THIS DOES NOT MEAN THAT THE LISTENER WAS NOT UPDATED. PLEASE MANUALLY CHECK THE LISTENER ON THE LOADBALANCER ({Listener_ARN}) TO CONFIRM THAT IT HAS BEEN UPDATED.")
            print("REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]")
          print("")
      InputPayload:
        region: '{{retrieveRegions.ACTIVE_REGION}}'
    description: Reverts the port on the -microservice load balancer listener back 443 to re-establish the connection used by shippingPartner2.
  - name: approvePostActions
    action: 'aws:approve'
    inputs:
      Approvers:
        - 'arn:aws:sts::account#:assumed-role/AdministratorAccess/user.1@generic.com'
        - 'arn:aws:sts::account#:assumed-role/AdministratorAccess/user.2@generic.com'
        - 'arn:aws:sts::account#:assumed-role/AdministratorAccess/user.3@generic.com'
        - 'arn:aws:sts::account#:assumed-role/AdministratorAccess/user.4@generic.com'
        - 'arn:aws:sts::account#:assumed-role/AdministratorAccess/user.5@generic.com'
        - 'arn:aws:sts::account#:assumed-role/AdministratorAccess/user.6@generic.com'
        - 'arn:aws:sts::account#:assumed-role/AdministratorAccess/user.7@generic.com'
        - 'arn:aws:sts::account#:assumed-role/AdministratorAccess/user.8@generic.com'
        - 'arn:aws:sts::account#:assumed-role/AdministratorAccess/user.9@generic.com'
        - 'arn:aws:sts::account#:assumed-role/AdministratorAccess/user.10@generic.com'
    description: 'Please use this step to confirm that the Disaster_Recovery to the standby region has completed successfully. Once you have confirmed, please navigate to AWS-ACCOUNT and approve the post-actions from there.'
  - name: stopServicesNewStandby
    action: 'aws:executeScript'
    inputs:
      Runtime: python3.6
      Handler: stopServicesNewStandby
      Script: "import boto3\nimport json\nimport botocore\nimport sys\nimport time\nimport re\nfrom datetime import datetime\n\ndef stopServicesNewStandby(event,context):\n  print(\"\")\n  \n  dt_raw = datetime.now()\n  date_time = dt_raw.strftime(\"%Y-%m-%dT%H:%M:00Z\")\n  active_region=event['active_region']\n  if (active_region == 'us-east-1'):\n    associationID = \"associationID\" #stopServicesNewStandby association in East\n    startAgain = \"associationID\" #startServicesNewStandby association in East. (only used for testing. this portion should be hashed out.)\n    instanceList = [\"instance1\",\"instance\",\"instance3\",\"instance4\",\"instance5\",\"instance6\",\"instance7\"] #_LOWER_ENVIRONMENT_APPLICATION_INSTANCES_EAST\n  elif (active_region == 'us-west-2'):\n    associationID\t= \"associationID\" #stopServicesNewStandby association in West\n    startAgain = \"associationID\" #startServicesNewStandby association in West. (only used for testing. this portion should be hashed out.)\n    instanceList = [\"instance1\",\"instance2\",\"instance3\",\"instance4\",\"instance5\",\"instance6\",\"instance7\"] #_LOWER_ENVIRONMENT_APPLICATION_INSTANCES_WEST\n  successCounter = 0\n  \n  client = boto3.client(service_name='ssm',region_name=active_region)\n  \n  response = client.start_associations_once(\n    AssociationIds=[\n      f\"{associationID}\"\n      ]\n    )\n  \n  time.sleep(20)\n  \n  #getting the command ID\n  getCommandId = client.list_command_invocations(\n    InstanceId=f\"{instanceList[0]}\",\n    Filters=[\n        {\n          'key': 'InvokedAfter',\n          'value': f\"{date_time}\"\n        }\n      ],\n    )\n  \n  #running another association to start the  processes again - STAGING ONLY\n  response = client.start_associations_once(\n    AssociationIds=[\n      f\"{startAgain}\"\n      ]\n    )\n    \n  #parsing the command ID\n  parseCommandId = re.search(r\"'CommandId': '(.*)', 'InstanceId':\", str(getCommandId))\n  try:\n    command_ID = parseCommandId.group(1)\n  \n    #getting association output from instances\n    associationOutputs = []\n    for i in range(len(instanceList)):\n      associationOutput = client.get_command_invocation(\n        CommandId=f\"{command_ID}\",\n        InstanceId=f\"{instanceList[i]}\",\n      )\n      associationOutputs.append(f\"{associationOutput}\")\n  \n    #parsing association output from instances\n    for x in range(len(associationOutputs)):\n      print(\"-\" + instanceList[x] + \"-\")\n      parseAssociationOutput = re.search(r\"'StandardOutputContent': '(.*)', 'StandardOutputUrl':\", str(associationOutputs[x]))\n      print(parseAssociationOutput.group(1))\n      if re.search(r\"\\bApplying action stopProcessId\\b\", str(associationOutputs[x])):\n        successCounter += 1\n    \n    print(\"\\n- - - - - - - - - - -\\n\")\n    if (successCounter == len(instanceList)):\n      print(\"STEP STATUS: SUCCESS!\")\n      print(f\"{successCounter} OF {len(instanceList)} INSTANCES SUCCESSFULLY RAN THE stopServicesNewStandby ({associationID}) ASSOCIATION.\")\n    elif (successCounter != len(instanceList)):\n      print(\"STEP STATUS: FAILED!\\nERROR CODE: 14A\")\n      print(f\"ONLY {successCounter} OF {len(instanceList)} INSTANCES WERE ABLE TO RUN THE stopServicesNewStandby ({associationID}) ASSOCIATION. PLEASE CHECK EACH APPLICATION INSTANCE MANUALLY.\")\n      print(\"REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]\")\n  except AttributeError:\n    print('THERE WAS AN ISSUE RETRIEVING OUTPUTS FROM THE ASSOCIATION. CHECKING ASSOCIATION STATUS...')\n    #if unable to grab or parse commandID, grabs association details\n    output = client.describe_association(\n      AssociationId=f\"{associationID}\",\n      AssociationVersion='$LATEST'\n      )\n  \n    validateSuccess = re.search(\"'Status': '(.*)', 'DetailedStatus'\", str(output))\n    \n    if (validateSuccess.group(1) == 'Success'):\n      print(\"STEP STATUS: SUCCESS!\")\n      print(f\"THE stopServicesNewStandby ({associationID}) ASSOCIATION WAS RUN SUCCESSFULLY!\")\n    elif (validateSuccess.group(1) == 'Pending'):\n      print(\"STEP STATUS: IN PROGRESS!\")\n      print(f\"THE ASSOCIATION IS STILL IN PROGRESS. MAKE SURE TO CHECK THE stopServicesNewStandby ({associationID}) ASSOCIATION IN AWS-ACCOUNT TO CONFIRM IT COMPLETES SUCCESSFULLY.\")\n  except:\n    print(\"STEP STATUS: UNKNOWN!\\nERROR CODE: 14B\")\n    print(f\"ASSOCIATION ID: {associationID}\")\n    print('THERE WAS AN ISSUE RETRIEVING OUTPUTS FROM THE ASSOCIATION. THIS DOES NOT MEAN THAT THE COMMANDS WERE NOT RUN.')\n    print(\"REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]\")\n    "
      InputPayload:
        active_region: '{{retrieveRegions.ACTIVE_REGION}}'
        date_time: '{{retrieveRegions.DATE_TIME}}'
    description: Stops all of the  services on the new standby stack
  - name: downsizeNewStandby
    action: 'aws:executeScript'
    description: Scales down the new standby region
    inputs:
      Runtime: python3.6
      Handler: modify_instance_type
      Script: |-
        import boto3
        import json
        import botocore
        import sys
        import re

        def modify_instance_type(event,context):
          print("\n")
          
          active_region = event['region']
          instanceType = 'db.t4g.medium' #instance type to upsize to
          successCounter = 0
          responseOutputs = []
          if (active_region == 'us-west-2'):
            nodeList = ["LOWER_ENVIRONMENT-db-node-0"] #docDB nodes in us-west-2
          elif (active_region == 'us-east-1'):
            nodeList = ["LOWER_ENVIRONMENT-db-node-0","LOWER_ENVIRONMENT-db-node-1","LOWER_ENVIRONMENT-db-node-2"] #docDB nodes in us-east-1
          
          client = boto3.client('docdb',region_name=active_region)
          
          for x in range(len(nodeList)):
            response = client.modify_db_instance(
              DBInstanceIdentifier=f"{nodeList[x]}",
              DBInstanceClass=instanceType,
              ApplyImmediately=True,
              )
            responseOutputs.append(f"{response}")
          
          #parsing response output from instances
          for i in range(len(responseOutputs)):
            try:
              parseResponseOutput = re.search(r"'PendingModifiedValues': {'DBInstanceClass': '(.*)'}, 'EngineVersion':", str(responseOutputs[i]))
              if (parseResponseOutput.group(1) == instanceType):
                successCounter += 1
            except AttributeError:
              if re.search(r"\b'PendingModifiedValues': {'DBInstanceClass': 'db.t4g.medium'}\b", str(responseOutputs[i])):
                successCounter += 1
            except:
              print(f"THERE WAS AN ISSUE VALIDATING SUCCESS FOR {nodeList[i]}.")
          
          if (successCounter == len(nodeList)):
            print("STEP STATUS: SUCCESS!")
            print(f"{successCounter} OF {len(nodeList)} NODES HAVE SUCCESSFULLY BEEN SENT THE REQUEST TO DOWNSIZE.")
          elif (successCounter != len(nodeList)):
            print("STEP STATUS: FAILED!\nERROR CODE: 15A")
            print(f"ONLY {successCounter} OF {len(nodeList)} NODES WERE SENT THE REQUEST TO DOWNSIZE.")
            print(f"NOTE: THE INSTANCES COULD ALREADY BE SCALED DOWN. PLEASE CHECK THE DOCDB NODES IN {active_region} TO CONFIRM THEY ARE SCALED DOWN.")
            print("REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]")
          else:
            print("STEP STATUS: UNKNOWN!\nERROR CODE: 15B")
            print(f"THERE WAS AN ISSUE RETRIEVING OUTPUTS FROM THE MODIFY DOCDB REQUESTS. THIS DOES NOT MEAN THE REQUESTS WERE NOT SENT, PLEASE CHECK THE DOCDB NODES IN {active_region} TO CONFIRM THEY ARE IN A MODIFYING STATE.")
            print("REFER TO THE ERROR CODE DOCUMENTATION FOR MORE INFO: [DOCUMENTATION_LINK_HERE]")
          print("")
          
      InputPayload:
        region: '{{retrieveRegions.ACTIVE_REGION}}'
